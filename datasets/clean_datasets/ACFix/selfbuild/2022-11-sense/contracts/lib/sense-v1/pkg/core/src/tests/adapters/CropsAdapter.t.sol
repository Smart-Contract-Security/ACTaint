pragma solidity 0.8.13;
import { ERC20 } from "solmate/tokens/ERC20.sol";
import { FixedMath } from "../../external/FixedMath.sol";
import { Errors } from "@sense-finance/v1-utils/src/libs/Errors.sol";
import { BaseAdapter } from "../../adapters/abstract/BaseAdapter.sol";
import { Divider } from "../../Divider.sol";
import { YT } from "../../tokens/YT.sol";
import { MockCropsAdapter } from "../test-helpers/mocks/MockAdapter.sol";
import { MockCropsFactory } from "../test-helpers/mocks/MockFactory.sol";
import { MockToken } from "../test-helpers/mocks/MockToken.sol";
import { MockTarget } from "../test-helpers/mocks/MockTarget.sol";
import { MockClaimer } from "../test-helpers/mocks/MockClaimer.sol";
import { TestHelper, MockTargetLike } from "../test-helpers/TestHelper.sol";
import { Constants } from "../test-helpers/Constants.sol";
contract CropsAdapters is TestHelper {
    using FixedMath for uint256;
    MockToken internal reward2;
    MockCropsAdapter internal cropsAdapter;
    MockCropsFactory internal cropsFactory;
    MockTargetLike internal aTarget;
    address[] public rewardTokens;
    function setUp() public virtual override {
        ISSUANCE_FEE = 0; 
        MAX_MATURITY = 52 weeks; 
        super.setUp();
        reward2 = new MockToken("Reward Token 2", "RT2", 6);
        aTarget = MockTargetLike(deployMockTarget(address(underlying), "Compound Dai", "cDAI", tDecimals));
        rewardTokens = [address(reward), address(reward2)];
        cropsFactory = MockCropsFactory(deployCropsFactory(address(aTarget), rewardTokens, true));
        address a = periphery.deployAdapter(address(cropsFactory), address(aTarget), abi.encode(rewardTokens)); 
        cropsAdapter = MockCropsAdapter(a);
        divider.setGuard(address(cropsAdapter), 10 * 2**128);
        initUser(alice, aTarget, AMT);
        initUser(bob, aTarget, AMT);
        initUser(jim, aTarget, AMT);
        if (!is4626Target) cropsAdapter.setScale(1e18);
    }
    function testAdapterHasParams() public {
        MockToken underlying = new MockToken("Dai", "DAI", 18);
        MockTargetLike target = MockTargetLike(
            deployMockTarget(address(underlying), "Compound Dai", "cDAI", tDecimals)
        );
        BaseAdapter.AdapterParams memory adapterParams = BaseAdapter.AdapterParams({
            oracle: ORACLE,
            stake: address(stake),
            stakeSize: STAKE_SIZE,
            minm: MIN_MATURITY,
            maxm: MAX_MATURITY,
            mode: MODE,
            tilt: 0,
            level: DEFAULT_LEVEL
        });
        MockCropsAdapter cropsAdapter = new MockCropsAdapter(
            address(divider),
            address(target),
            !is4626Target ? target.underlying() : target.asset(),
            Constants.REWARDS_RECIPIENT,
            ISSUANCE_FEE,
            adapterParams,
            rewardTokens
        );
        (address oracle, address stake, uint256 stakeSize, uint256 minm, uint256 maxm, , , ) = cropsAdapter
            .adapterParams();
        assertEq(cropsAdapter.rewardTokens(0), address(reward));
        assertEq(cropsAdapter.rewardTokens(1), address(reward2));
        assertEq(cropsAdapter.name(), "Compound Dai Adapter");
        assertEq(cropsAdapter.symbol(), "cDAI-adapter");
        assertEq(cropsAdapter.target(), address(target));
        assertEq(cropsAdapter.underlying(), address(underlying));
        assertEq(cropsAdapter.divider(), address(divider));
        assertEq(cropsAdapter.rewardsRecipient(), Constants.REWARDS_RECIPIENT);
        assertEq(cropsAdapter.ifee(), ISSUANCE_FEE);
        assertEq(stake, address(stake));
        assertEq(stakeSize, STAKE_SIZE);
        assertEq(minm, MIN_MATURITY);
        assertEq(maxm, MAX_MATURITY);
        assertEq(oracle, ORACLE);
        assertEq(cropsAdapter.mode(), MODE);
    }
    function testExtractToken() public {
        MockToken someReward = new MockToken("Some Reward", "SR", 18);
        someReward.mint(address(cropsAdapter), 1e18);
        assertEq(someReward.balanceOf(address(cropsAdapter)), 1e18);
        vm.expectEmit(true, true, true, true);
        emit RewardsClaimed(address(someReward), Constants.REWARDS_RECIPIENT, 1e18);
        assertEq(someReward.balanceOf(Constants.REWARDS_RECIPIENT), 0);
        vm.prank(address(0xfede));
        cropsAdapter.extractToken(address(someReward));
        assertEq(someReward.balanceOf(Constants.REWARDS_RECIPIENT), 1e18);
        (address target, address stake, ) = cropsAdapter.getStakeAndTarget();
        vm.expectRevert(abi.encodeWithSelector(Errors.TokenNotSupported.selector));
        cropsAdapter.extractToken(address(stake));
        vm.expectRevert(abi.encodeWithSelector(Errors.TokenNotSupported.selector));
        cropsAdapter.extractToken(address(target));
        vm.expectRevert(abi.encodeWithSelector(Errors.TokenNotSupported.selector));
        cropsAdapter.extractToken(address(reward));
        vm.expectRevert(abi.encodeWithSelector(Errors.TokenNotSupported.selector));
        cropsAdapter.extractToken(address(reward2));
    }
    function testFuzzDistribution(uint256 tBal) public {
        assumeBounds(tBal);
        uint256 maturity = getValidMaturity(2021, 10);
        periphery.sponsorSeries(address(cropsAdapter), maturity, true);
        divider.issue(address(cropsAdapter), maturity, (60 * tBal) / 100);
        vm.prank(bob);
        divider.issue(address(cropsAdapter), maturity, (40 * tBal) / 100);
        reward.mint(address(cropsAdapter), 50 * 10**rDecimals);
        reward2.mint(address(cropsAdapter), 50 * 1e6);
        vm.expectEmit(true, true, true, false);
        emit Distributed(alice, address(reward), 0);
        vm.expectEmit(true, true, true, false);
        emit Distributed(alice, address(reward2), 0);
        divider.issue(address(cropsAdapter), maturity, 0);
        assertApproxRewardBal(ERC20(reward).balanceOf(alice), 30 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(alice), 30 * 1e6);
        assertApproxRewardBal(ERC20(reward).balanceOf(bob), 0);
        assertApproxRewardBal(ERC20(reward2).balanceOf(bob), 0 * 1e6);
        vm.prank(bob);
        divider.issue(address(cropsAdapter), maturity, 0);
        assertApproxRewardBal(ERC20(reward).balanceOf(alice), 30 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(alice), 30 * 1e6);
        assertApproxRewardBal(ERC20(reward).balanceOf(bob), 20 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(bob), 20 * 1e6);
        divider.issue(address(cropsAdapter), maturity, 0);
        vm.prank(bob);
        divider.issue(address(cropsAdapter), maturity, 0);
        assertApproxRewardBal(ERC20(reward).balanceOf(alice), 30 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(alice), 30 * 1e6);
        assertApproxRewardBal(ERC20(reward).balanceOf(bob), 20 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(bob), 20 * 1e6);
    }
    function testFuzzSingleDistribution(uint256 tBal) public {
        assumeBounds(tBal);
        uint256 maturity = getValidMaturity(2021, 10);
        (, address yt) = periphery.sponsorSeries(address(cropsAdapter), maturity, true);
        divider.issue(address(cropsAdapter), maturity, (100 * tBal) / 100);
        assertApproxRewardBal(ERC20(reward).balanceOf(alice), 0);
        reward.mint(address(cropsAdapter), 10 * 10**rDecimals);
        reward2.mint(address(cropsAdapter), 10 * 1e6);
        divider.issue(address(cropsAdapter), maturity, 0);
        assertApproxRewardBal(ERC20(reward).balanceOf(alice), 10 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(alice), 10 * 1e6);
        divider.issue(address(cropsAdapter), maturity, (100 * tBal) / 100);
        assertApproxRewardBal(ERC20(reward).balanceOf(alice), 10 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(alice), 10 * 1e6);
        divider.combine(address(cropsAdapter), maturity, ERC20(yt).balanceOf(alice));
        assertApproxRewardBal(ERC20(reward).balanceOf(alice), 10 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(alice), 10 * 1e6);
        divider.issue(address(cropsAdapter), maturity, (50 * tBal) / 100);
        assertApproxRewardBal(ERC20(reward).balanceOf(alice), 10 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(alice), 10 * 1e6);
        reward.mint(address(cropsAdapter), 10 * 10**rDecimals);
        reward2.mint(address(cropsAdapter), 10 * 1e6);
        divider.issue(address(cropsAdapter), maturity, (10 * tBal) / 100);
        assertApproxRewardBal(ERC20(reward).balanceOf(alice), 20 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(alice), 20 * 1e6);
    }
    function testFuzzProportionalDistribution() public {
        uint256 tBal = 100 * 10**rDecimals;
        uint256 maturity = getValidMaturity(2021, 10);
        (, address yt) = periphery.sponsorSeries(address(cropsAdapter), maturity, true);
        divider.issue(address(cropsAdapter), maturity, (60 * tBal) / 100);
        vm.prank(bob);
        divider.issue(address(cropsAdapter), maturity, (40 * tBal) / 100);
        reward.mint(address(cropsAdapter), 50 * 10**rDecimals);
        reward2.mint(address(cropsAdapter), 50 * 1e6);
        divider.issue(address(cropsAdapter), maturity, 0);
        assertApproxRewardBal(ERC20(reward).balanceOf(alice), 30 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(alice), 30 * 1e6);
        assertApproxRewardBal(ERC20(reward).balanceOf(bob), 0);
        assertApproxRewardBal(ERC20(reward2).balanceOf(bob), 0);
        vm.prank(bob);
        divider.issue(address(cropsAdapter), maturity, 0);
        assertApproxRewardBal(ERC20(reward).balanceOf(alice), 30 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(alice), 30 * 1e6);
        assertApproxRewardBal(ERC20(reward).balanceOf(bob), 20 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(bob), 20 * 1e6);
        divider.issue(address(cropsAdapter), maturity, 0);
        vm.prank(bob);
        divider.issue(address(cropsAdapter), maturity, 0);
        assertApproxRewardBal(ERC20(reward).balanceOf(alice), 30 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(alice), 30 * 1e6);
        assertApproxRewardBal(ERC20(reward).balanceOf(bob), 20 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(bob), 20 * 1e6);
        reward.mint(address(cropsAdapter), 50 * 10**rDecimals);
        reward2.mint(address(cropsAdapter), 50 * 1e6);
        divider.issue(address(cropsAdapter), maturity, (20 * tBal) / 100);
        vm.prank(bob);
        divider.issue(address(cropsAdapter), maturity, 0);
        assertApproxRewardBal(ERC20(reward).balanceOf(alice), 60 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(alice), 60 * 1e6);
        assertApproxRewardBal(ERC20(reward).balanceOf(bob), 40 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(bob), 40 * 1e6);
        reward.mint(address(cropsAdapter), 30 * 10**rDecimals);
        reward2.mint(address(cropsAdapter), 30 * 1e6);
        divider.issue(address(cropsAdapter), maturity, 0);
        vm.prank(bob);
        divider.issue(address(cropsAdapter), maturity, 0);
        assertApproxRewardBal(ERC20(reward).balanceOf(alice), 80 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(alice), 80 * 1e6);
        assertApproxRewardBal(ERC20(reward).balanceOf(bob), 50 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(bob), 50 * 1e6);
        divider.combine(address(cropsAdapter), maturity, ERC20(yt).balanceOf(alice));
    }
    function testFuzzSimpleDistributionAndCollect(uint256 tBal) public {
        assumeBounds(tBal);
        uint256 maturity = getValidMaturity(2021, 10);
        (, address yt) = periphery.sponsorSeries(address(cropsAdapter), maturity, true);
        divider.issue(address(cropsAdapter), maturity, (60 * tBal) / 100);
        vm.prank(bob);
        divider.issue(address(cropsAdapter), maturity, (40 * tBal) / 100);
        assertEq(reward.balanceOf(bob), 0);
        assertEq(reward2.balanceOf(bob), 0);
        reward.mint(address(cropsAdapter), 60 * 10**rDecimals);
        reward2.mint(address(cropsAdapter), 60 * 1e6);
        vm.prank(bob);
        YT(yt).collect();
        assertApproxRewardBal(reward.balanceOf(bob), 24 * 10**rDecimals);
        assertApproxRewardBal(reward2.balanceOf(bob), 24 * 1e6);
    }
    function testFuzzDistributionCollectAndTransferMultiStep(uint256 tBal) public {
        assumeBounds(tBal);
        uint256 maturity = getValidMaturity(2021, 10);
        (, address yt) = periphery.sponsorSeries(address(cropsAdapter), maturity, true);
        divider.issue(address(cropsAdapter), maturity, (60 * tBal) / 100);
        vm.prank(bob);
        divider.issue(address(cropsAdapter), maturity, (40 * tBal) / 100);
        assertEq(reward.balanceOf(bob), 0);
        assertEq(reward2.balanceOf(bob), 0);
        reward.mint(address(cropsAdapter), 60 * 10**rDecimals);
        reward2.mint(address(cropsAdapter), 60 * 1e6);
        vm.warp(block.timestamp + 1 days);
        vm.prank(jim);
        divider.issue(address(cropsAdapter), maturity, (100 * tBal) / 100);
        vm.warp(block.timestamp + 1 days);
        reward.mint(address(cropsAdapter), 100 * 10**rDecimals);
        reward2.mint(address(cropsAdapter), 100 * 1e6);
        uint256 bytBal = ERC20(yt).balanceOf(bob);
        vm.prank(bob);
        MockToken(yt).transfer(jim, bytBal);
        assertApproxRewardBal(reward.balanceOf(bob), 44 * 10**rDecimals);
        assertApproxRewardBal(reward2.balanceOf(bob), 44 * 1e6);
        assertApproxRewardBal(reward.balanceOf(jim), 50 * 10**rDecimals);
        assertApproxRewardBal(reward2.balanceOf(jim), 50 * 1e6);
        YT(yt).collect();
        assertApproxRewardBal(reward.balanceOf(alice), 66 * 10**rDecimals);
        assertApproxRewardBal(reward2.balanceOf(alice), 66 * 1e6);
        vm.warp(block.timestamp + 1 days);
        reward.mint(address(cropsAdapter), 100 * 10**rDecimals);
        reward2.mint(address(cropsAdapter), 100 * 1e6);
        vm.prank(jim);
        YT(yt).collect();
        assertApproxRewardBal(reward.balanceOf(jim), 120 * 10**rDecimals);
        assertApproxRewardBal(reward2.balanceOf(jim), 120 * 1e6);
        YT(yt).collect();
        assertApproxRewardBal(reward.balanceOf(alice), 96 * 10**rDecimals);
        assertApproxRewardBal(reward2.balanceOf(alice), 96 * 1e6);
    }
    function testFuzzDistributionAddRewardToken(uint256 tBal) public {
        assumeBounds(tBal);
        uint256 maturity = getValidMaturity(2021, 10);
        (, address yt) = periphery.sponsorSeries(address(cropsAdapter), maturity, true);
        divider.issue(address(cropsAdapter), maturity, (100 * tBal) / 100);
        assertApproxRewardBal(ERC20(reward).balanceOf(alice), 0);
        reward.mint(address(cropsAdapter), 10 * 10**rDecimals);
        reward2.mint(address(cropsAdapter), 10 * 1e6);
        divider.issue(address(cropsAdapter), maturity, 0);
        assertApproxRewardBal(ERC20(reward).balanceOf(alice), 10 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(alice), 10 * 1e6);
        MockToken reward3 = new MockToken("Reward Token 3", "RT3", 18);
        rewardTokens.push(address(reward3));
        vm.prank(address(cropsFactory));
        cropsAdapter.setRewardTokens(rewardTokens);
        divider.issue(address(cropsAdapter), maturity, (100 * tBal) / 100);
        assertApproxRewardBal(ERC20(reward).balanceOf(alice), 10 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(alice), 10 * 1e6);
        assertApproxRewardBal(ERC20(reward3).balanceOf(alice), 0);
        divider.combine(address(cropsAdapter), maturity, ERC20(yt).balanceOf(alice));
        assertApproxRewardBal(ERC20(reward).balanceOf(alice), 10 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(alice), 10 * 1e6);
        assertApproxRewardBal(ERC20(reward3).balanceOf(alice), 0);
        divider.issue(address(cropsAdapter), maturity, (50 * tBal) / 100);
        assertApproxRewardBal(ERC20(reward).balanceOf(alice), 10 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(alice), 10 * 1e6);
        assertApproxRewardBal(ERC20(reward3).balanceOf(alice), 0);
        reward.mint(address(cropsAdapter), 10 * 10**rDecimals);
        reward2.mint(address(cropsAdapter), 10 * 1e6);
        reward3.mint(address(cropsAdapter), 10 * 10**rDecimals);
        divider.issue(address(cropsAdapter), maturity, (10 * tBal) / 100);
        assertApproxRewardBal(ERC20(reward).balanceOf(alice), 20 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(alice), 20 * 1e6);
        assertApproxRewardBal(ERC20(reward3).balanceOf(alice), 10 * 10**rDecimals);
    }
    function testFuzzDistributionRemoveRewardToken(uint256 tBal) public {
        assumeBounds(tBal);
        uint256 maturity = getValidMaturity(2021, 10);
        (, address yt) = periphery.sponsorSeries(address(cropsAdapter), maturity, true);
        divider.issue(address(cropsAdapter), maturity, (100 * tBal) / 100);
        assertApproxRewardBal(ERC20(reward).balanceOf(alice), 0);
        reward.mint(address(cropsAdapter), 10 * 10**rDecimals);
        reward2.mint(address(cropsAdapter), 10 * 1e6);
        divider.issue(address(cropsAdapter), maturity, 0);
        assertApproxRewardBal(ERC20(reward).balanceOf(alice), 10 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(alice), 10 * 1e6);
        rewardTokens.pop();
        vm.prank(address(cropsFactory));
        cropsAdapter.setRewardTokens(rewardTokens);
        divider.issue(address(cropsAdapter), maturity, (100 * tBal) / 100);
        assertApproxRewardBal(ERC20(reward).balanceOf(alice), 10 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(alice), 10 * 1e6);
        divider.combine(address(cropsAdapter), maturity, ERC20(yt).balanceOf(alice));
        assertApproxRewardBal(ERC20(reward).balanceOf(alice), 10 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(alice), 10 * 1e6);
        divider.issue(address(cropsAdapter), maturity, (50 * tBal) / 100);
        assertApproxRewardBal(ERC20(reward).balanceOf(alice), 10 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(alice), 10 * 1e6);
        reward.mint(address(cropsAdapter), 10 * 10**rDecimals);
        reward2.mint(address(cropsAdapter), 10 * 1e6);
        divider.issue(address(cropsAdapter), maturity, (10 * tBal) / 100);
        assertApproxRewardBal(ERC20(reward).balanceOf(alice), 20 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(alice), 10 * 1e6);
    }
    function testFuzzCollectRewardSettleSeriesAndCheckTBalanceIsZero(uint256 tBal) public {
        tBal = uint128(bound(tBal, 1, MAX_TARGET));
        uint256 maturity = getValidMaturity(2021, 10);
        (, address yt) = periphery.sponsorSeries(address(cropsAdapter), maturity, true);
        divider.issue(address(cropsAdapter), maturity, tBal);
        uint256 airdrop = 1e18;
        reward.mint(address(cropsAdapter), airdrop);
        reward2.mint(address(cropsAdapter), airdrop);
        YT(yt).collect();
        assertTrue(cropsAdapter.tBalance(alice) > 0);
        reward2.mint(address(cropsAdapter), airdrop);
        vm.warp(maturity);
        divider.settleSeries(address(cropsAdapter), maturity);
        YT(yt).collect();
        assertEq(cropsAdapter.tBalance(alice), 0);
        uint256 collected = YT(yt).collect(); 
        assertEq(collected, 0);
    }
    function testFuzzReconcileMoreThanOnce(uint256 tBal) public {
        assumeBounds(tBal);
        uint256 maturity = getValidMaturity(2021, 10);
        (, address yt) = periphery.sponsorSeries(address(cropsAdapter), maturity, true);
        divider.issue(address(cropsAdapter), maturity, (60 * tBal) / 100); 
        vm.prank(bob);
        divider.issue(address(cropsAdapter), maturity, (40 * tBal) / 100); 
        assertEq(reward.balanceOf(bob), 0);
        assertEq(reward2.balanceOf(bob), 0);
        reward.mint(address(cropsAdapter), 50 * 10**rDecimals);
        reward2.mint(address(cropsAdapter), 50 * 10**rDecimals);
        vm.warp(maturity + 1 seconds);
        divider.settleSeries(address(cropsAdapter), maturity);
        assertApproxRewardBal(cropsAdapter.tBalance(bob), (40 * tBal) / 100);
        assertApproxRewardBal(cropsAdapter.reconciledAmt(bob), 0);
        uint256[] memory maturities = new uint256[](1);
        maturities[0] = maturity;
        address[] memory users = new address[](1);
        users[0] = bob;
        vm.expectEmit(true, false, false, false);
        emit Reconciled(bob, 0, maturity);
        cropsAdapter.reconcile(users, maturities);
        cropsAdapter.reconcile(users, maturities);
        assertApproxRewardBal(cropsAdapter.tBalance(bob), 0);
        assertApproxRewardBal(cropsAdapter.reconciledAmt(bob), (40 * tBal) / 100);
        assertApproxRewardBal(reward.balanceOf(bob), 20 * 10**rDecimals);
        assertApproxRewardBal(reward2.balanceOf(bob), 20 * 10**rDecimals);
    }
    function testFuzzGetMaturedSeriesRewardsIfReconcileAfterMaturity(uint256 tBal) public {
        assumeBounds(tBal);
        uint256 maturity = getValidMaturity(2021, 10);
        (, address yt) = periphery.sponsorSeries(address(cropsAdapter), maturity, true);
        divider.issue(address(cropsAdapter), maturity, (60 * tBal) / 100); 
        vm.prank(bob);
        divider.issue(address(cropsAdapter), maturity, (40 * tBal) / 100); 
        assertEq(reward.balanceOf(bob), 0);
        assertEq(reward2.balanceOf(bob), 0);
        reward.mint(address(cropsAdapter), 50 * 10**rDecimals);
        reward2.mint(address(cropsAdapter), 50 * 10**rDecimals);
        vm.warp(maturity + 1 seconds);
        divider.settleSeries(address(cropsAdapter), maturity);
        assertApproxRewardBal(cropsAdapter.tBalance(bob), (40 * tBal) / 100);
        assertApproxRewardBal(cropsAdapter.reconciledAmt(bob), 0);
        uint256[] memory maturities = new uint256[](1);
        maturities[0] = maturity;
        address[] memory users = new address[](1);
        users[0] = bob;
        cropsAdapter.reconcile(users, maturities);
        assertApproxRewardBal(cropsAdapter.tBalance(bob), 0);
        assertApproxRewardBal(cropsAdapter.reconciledAmt(bob), (40 * tBal) / 100);
        assertApproxRewardBal(reward.balanceOf(bob), 20 * 10**rDecimals);
        assertApproxRewardBal(reward2.balanceOf(bob), 20 * 10**rDecimals);
    }
    function testFuzzCantDiluteRewardsIfReconciledInSingleDistribution(uint256 tBal) public {
        assumeBounds(tBal);
        uint256 maturity = getValidMaturity(2021, 10);
        (, address yt) = periphery.sponsorSeries(address(cropsAdapter), maturity, true);
        divider.issue(address(cropsAdapter), maturity, (100 * tBal) / 100);
        assertApproxRewardBal(ERC20(reward).balanceOf(alice), 0);
        assertApproxRewardBal(ERC20(reward2).balanceOf(alice), 0);
        reward.mint(address(cropsAdapter), 10 * 10**rDecimals);
        reward2.mint(address(cropsAdapter), 10 * 10**rDecimals);
        YT(yt).collect();
        assertApproxRewardBal(ERC20(reward).balanceOf(alice), 10 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(alice), 10 * 10**rDecimals);
        divider.issue(address(cropsAdapter), maturity, (100 * tBal) / 100);
        assertApproxRewardBal(ERC20(reward).balanceOf(alice), 10 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(alice), 10 * 10**rDecimals);
        reward.mint(address(cropsAdapter), 20 * 10**rDecimals);
        reward2.mint(address(cropsAdapter), 20 * 10**rDecimals);
        vm.warp(maturity + 1 seconds);
        divider.settleSeries(address(cropsAdapter), maturity);
        assertEq(cropsAdapter.tBalance(alice), (200 * tBal) / 100);
        assertEq(cropsAdapter.reconciledAmt(alice), 0);
        uint256[] memory maturities = new uint256[](1);
        maturities[0] = maturity;
        address[] memory users = new address[](1);
        users[0] = alice;
        cropsAdapter.reconcile(users, maturities);
        assertEq(cropsAdapter.reconciledAmt(alice), (200 * tBal) / 100);
        assertEq(cropsAdapter.tBalance(alice), 0);
        assertApproxRewardBal(ERC20(reward).balanceOf(alice), 30 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(alice), 30 * 10**rDecimals);
        uint256 newMaturity = getValidMaturity(2021, 11);
        periphery.sponsorSeries(address(cropsAdapter), newMaturity, true);
        divider.issue(address(cropsAdapter), newMaturity, (50 * tBal) / 100);
        assertApproxRewardBal(ERC20(reward).balanceOf(alice), 30 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(alice), 30 * 10**rDecimals);
        reward.mint(address(cropsAdapter), 30 * 10**rDecimals);
        reward2.mint(address(cropsAdapter), 30 * 10**rDecimals);
        divider.issue(address(cropsAdapter), newMaturity, (10 * tBal) / 100);
        assertApproxRewardBal(ERC20(reward).balanceOf(alice), 60 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(alice), 60 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(alice), 60 * 10**rDecimals);
        divider.combine(address(cropsAdapter), maturity, ERC20(yt).balanceOf(alice));
        assertApproxRewardBal(ERC20(reward).balanceOf(alice), 60 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(alice), 60 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(alice), 60 * 10**rDecimals);
    }
    function testFuzzCantDiluteRewardsIfReconciledAndCombineS1_YTsFirstI(uint256 tBal) public {
        assumeBounds(tBal);
        uint256 maturity = getValidMaturity(2021, 10);
        (, address yt) = periphery.sponsorSeries(address(cropsAdapter), maturity, true);
        divider.issue(address(cropsAdapter), maturity, (60 * tBal) / 100); 
        vm.prank(bob);
        divider.issue(address(cropsAdapter), maturity, (40 * tBal) / 100); 
        reward.mint(address(cropsAdapter), 50 * 10**rDecimals);
        reward2.mint(address(cropsAdapter), 50 * 10**rDecimals);
        YT(yt).collect();
        vm.prank(bob);
        YT(yt).collect();
        assertApproxRewardBal(ERC20(reward).balanceOf(alice), 30 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(alice), 30 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward).balanceOf(bob), 20 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(bob), 20 * 10**rDecimals);
        reward.mint(address(cropsAdapter), 50 * 10**rDecimals);
        reward2.mint(address(cropsAdapter), 50 * 10**rDecimals);
        vm.warp(maturity + 1 seconds);
        divider.settleSeries(address(cropsAdapter), maturity);
        assertApproxRewardBal(cropsAdapter.reconciledAmt(alice), 0);
        assertApproxRewardBal(cropsAdapter.reconciledAmt(bob), 0);
        assertApproxRewardBal(cropsAdapter.tBalance(alice), (60 * tBal) / 100);
        assertApproxRewardBal(cropsAdapter.tBalance(bob), (40 * tBal) / 100);
        uint256[] memory maturities = new uint256[](1);
        maturities[0] = maturity;
        address[] memory users = new address[](2);
        users[0] = alice;
        users[1] = bob;
        cropsAdapter.reconcile(users, maturities);
        assertApproxRewardBal(cropsAdapter.tBalance(alice), 0);
        assertApproxRewardBal(cropsAdapter.tBalance(bob), 0);
        assertApproxRewardBal(cropsAdapter.reconciledAmt(alice), (60 * tBal) / 100);
        assertApproxRewardBal(cropsAdapter.reconciledAmt(bob), (40 * tBal) / 100);
        assertApproxRewardBal(ERC20(reward).balanceOf(alice), 60 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(alice), 60 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward).balanceOf(bob), 40 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(bob), 40 * 10**rDecimals);
        uint256 newMaturity = getValidMaturity(2021, 11);
        (, address newYt) = periphery.sponsorSeries(address(cropsAdapter), newMaturity, true);
        divider.issue(address(cropsAdapter), newMaturity, (60 * tBal) / 100);
        assertApproxRewardBal(cropsAdapter.tBalance(alice), (60 * tBal) / 100);
        assertApproxRewardBal(cropsAdapter.reconciledAmt(alice), (60 * tBal) / 100);
        vm.prank(bob);
        divider.issue(address(cropsAdapter), newMaturity, (40 * tBal) / 100);
        assertApproxRewardBal(cropsAdapter.tBalance(bob), (40 * tBal) / 100);
        assertApproxRewardBal(cropsAdapter.reconciledAmt(bob), (40 * tBal) / 100);
        assertApproxRewardBal(ERC20(reward).balanceOf(alice), 60 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(alice), 60 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward).balanceOf(bob), 40 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(bob), 40 * 10**rDecimals);
        reward.mint(address(cropsAdapter), 50 * 10**rDecimals);
        reward2.mint(address(cropsAdapter), 50 * 10**rDecimals);
        vm.prank(bob);
        YT(yt).collect();
        divider.issue(address(cropsAdapter), newMaturity, 0);
        assertApproxRewardBal(ERC20(reward).balanceOf(alice), 90 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(alice), 90 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward).balanceOf(bob), 60 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(bob), 60 * 10**rDecimals);
        divider.combine(address(cropsAdapter), maturity, ERC20(yt).balanceOf(alice));
        assertApproxRewardBal(cropsAdapter.tBalance(alice), (60 * tBal) / 100);
        assertApproxRewardBal(cropsAdapter.reconciledAmt(alice), 0);
        divider.combine(address(cropsAdapter), newMaturity, ERC20(newYt).balanceOf(alice));
        assertApproxRewardBal(cropsAdapter.tBalance(alice), 0);
        assertApproxRewardBal(cropsAdapter.reconciledAmt(alice), 0);
        assertApproxRewardBal(cropsAdapter.tBalance(bob), (40 * tBal) / 100);
        assertApproxRewardBal(cropsAdapter.reconciledAmt(bob), 0);
    }
    function testFuzzCantDiluteRewardsIfReconciledAndCombineS1_YTsFirstII(uint256 tBal) public {
        assumeBounds(tBal);
        uint256 maturity = getValidMaturity(2021, 10);
        (, address yt) = periphery.sponsorSeries(address(cropsAdapter), maturity, true);
        divider.issue(address(cropsAdapter), maturity, (60 * tBal) / 100); 
        vm.prank(bob);
        divider.issue(address(cropsAdapter), maturity, (40 * tBal) / 100); 
        reward.mint(address(cropsAdapter), 50 * 10**rDecimals);
        reward2.mint(address(cropsAdapter), 50 * 10**rDecimals);
        YT(yt).collect();
        vm.prank(bob);
        YT(yt).collect();
        assertApproxRewardBal(ERC20(reward).balanceOf(alice), 30 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward).balanceOf(bob), 20 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(alice), 30 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(bob), 20 * 10**rDecimals);
        reward.mint(address(cropsAdapter), 50 * 10**rDecimals);
        reward2.mint(address(cropsAdapter), 50 * 10**rDecimals);
        vm.warp(maturity + 1 seconds);
        divider.settleSeries(address(cropsAdapter), maturity);
        assertApproxRewardBal(cropsAdapter.reconciledAmt(alice), 0);
        assertApproxRewardBal(cropsAdapter.reconciledAmt(bob), 0);
        assertApproxRewardBal(cropsAdapter.tBalance(alice), (60 * tBal) / 100);
        assertApproxRewardBal(cropsAdapter.tBalance(bob), (40 * tBal) / 100);
        uint256[] memory maturities = new uint256[](1);
        maturities[0] = maturity;
        address[] memory users = new address[](2);
        users[0] = alice;
        users[1] = bob;
        cropsAdapter.reconcile(users, maturities);
        assertApproxRewardBal(cropsAdapter.tBalance(alice), 0);
        assertApproxRewardBal(cropsAdapter.tBalance(bob), 0);
        assertApproxRewardBal(cropsAdapter.reconciledAmt(alice), (60 * tBal) / 100);
        assertApproxRewardBal(cropsAdapter.reconciledAmt(bob), (40 * tBal) / 100);
        assertApproxRewardBal(ERC20(reward).balanceOf(alice), 60 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(alice), 60 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward).balanceOf(bob), 40 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(bob), 40 * 10**rDecimals);
        uint256 newMaturity = getValidMaturity(2021, 11);
        (, address newYt) = periphery.sponsorSeries(address(cropsAdapter), newMaturity, true);
        divider.issue(address(cropsAdapter), newMaturity, (120 * tBal) / 100);
        assertApproxRewardBal(cropsAdapter.tBalance(alice), (120 * tBal) / 100);
        assertApproxRewardBal(cropsAdapter.reconciledAmt(alice), (60 * tBal) / 100);
        vm.prank(bob);
        divider.issue(address(cropsAdapter), newMaturity, (80 * tBal) / 100);
        assertApproxRewardBal(cropsAdapter.tBalance(bob), (80 * tBal) / 100);
        assertApproxRewardBal(cropsAdapter.reconciledAmt(bob), (40 * tBal) / 100);
        assertApproxRewardBal(ERC20(reward).balanceOf(alice), 60 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(alice), 60 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward).balanceOf(bob), 40 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(bob), 40 * 10**rDecimals);
        reward.mint(address(cropsAdapter), 50 * 10**rDecimals);
        reward2.mint(address(cropsAdapter), 50 * 10**rDecimals);
        YT(newYt).collect();
        vm.prank(bob);
        divider.issue(address(cropsAdapter), newMaturity, 0);
        assertApproxRewardBal(ERC20(reward).balanceOf(alice), 90 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(alice), 90 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward).balanceOf(bob), 60 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(bob), 60 * 10**rDecimals);
        divider.combine(address(cropsAdapter), maturity, ERC20(yt).balanceOf(alice));
        assertApproxRewardBal(cropsAdapter.tBalance(alice), (120 * tBal) / 100);
        assertApproxRewardBal(cropsAdapter.reconciledAmt(alice), 0);
        divider.combine(address(cropsAdapter), newMaturity, ERC20(newYt).balanceOf(alice));
        assertApproxRewardBal(cropsAdapter.tBalance(alice), 0);
        assertApproxRewardBal(cropsAdapter.reconciledAmt(alice), 0);
        assertApproxRewardBal(cropsAdapter.tBalance(bob), (80 * tBal) / 100);
        assertApproxRewardBal(cropsAdapter.reconciledAmt(bob), (40 * tBal) / 100);
    }
    function testFuzzCantDiluteRewardsIfReconciledAndCombineS1_YTsFirstIII(uint256 tBal) public {
        assumeBounds(tBal);
        uint256 maturity = getValidMaturity(2021, 10);
        (, address yt) = periphery.sponsorSeries(address(cropsAdapter), maturity, true);
        divider.issue(address(cropsAdapter), maturity, (60 * tBal) / 100); 
        vm.prank(bob);
        divider.issue(address(cropsAdapter), maturity, (40 * tBal) / 100); 
        reward.mint(address(cropsAdapter), 50 * 10**rDecimals);
        reward2.mint(address(cropsAdapter), 50 * 10**rDecimals);
        YT(yt).collect();
        vm.prank(bob);
        YT(yt).collect();
        assertApproxRewardBal(ERC20(reward).balanceOf(alice), 30 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward).balanceOf(bob), 20 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(alice), 30 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(bob), 20 * 10**rDecimals);
        reward.mint(address(cropsAdapter), 50 * 10**rDecimals);
        reward2.mint(address(cropsAdapter), 50 * 10**rDecimals);
        vm.warp(maturity + 1 seconds);
        divider.settleSeries(address(cropsAdapter), maturity);
        assertApproxRewardBal(cropsAdapter.reconciledAmt(alice), 0);
        assertApproxRewardBal(cropsAdapter.reconciledAmt(bob), 0);
        assertApproxRewardBal(cropsAdapter.tBalance(alice), (60 * tBal) / 100);
        assertApproxRewardBal(cropsAdapter.tBalance(bob), (40 * tBal) / 100);
        uint256[] memory maturities = new uint256[](1);
        maturities[0] = maturity;
        address[] memory users = new address[](2);
        users[0] = alice;
        users[1] = bob;
        cropsAdapter.reconcile(users, maturities);
        assertApproxRewardBal(cropsAdapter.tBalance(alice), 0);
        assertApproxRewardBal(cropsAdapter.tBalance(bob), 0);
        assertApproxRewardBal(cropsAdapter.reconciledAmt(alice), (60 * tBal) / 100);
        assertApproxRewardBal(cropsAdapter.reconciledAmt(bob), (40 * tBal) / 100);
        assertApproxRewardBal(ERC20(reward).balanceOf(alice), 60 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(alice), 60 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward).balanceOf(bob), 40 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(bob), 40 * 10**rDecimals);
        uint256 newMaturity = getValidMaturity(2021, 11);
        (, address newYt) = periphery.sponsorSeries(address(cropsAdapter), newMaturity, true);
        divider.issue(address(cropsAdapter), newMaturity, (30 * tBal) / 100);
        assertApproxRewardBal(cropsAdapter.tBalance(alice), (30 * tBal) / 100);
        assertApproxRewardBal(cropsAdapter.reconciledAmt(alice), (60 * tBal) / 100);
        vm.prank(bob);
        divider.issue(address(cropsAdapter), newMaturity, (20 * tBal) / 100);
        assertApproxRewardBal(cropsAdapter.tBalance(bob), (20 * tBal) / 100);
        assertApproxRewardBal(cropsAdapter.reconciledAmt(bob), (40 * tBal) / 100);
        assertApproxRewardBal(ERC20(reward).balanceOf(alice), 60 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(alice), 60 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward).balanceOf(bob), 40 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(bob), 40 * 10**rDecimals);
        reward.mint(address(cropsAdapter), 50 * 10**rDecimals);
        reward2.mint(address(cropsAdapter), 50 * 10**rDecimals);
        YT(yt).collect();
        vm.prank(bob);
        divider.issue(address(cropsAdapter), newMaturity, 0);
        assertApproxRewardBal(ERC20(reward).balanceOf(alice), 90 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(alice), 90 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward).balanceOf(bob), 60 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(bob), 60 * 10**rDecimals);
        divider.combine(address(cropsAdapter), maturity, ERC20(yt).balanceOf(alice));
        assertApproxRewardBal(cropsAdapter.tBalance(alice), (30 * tBal) / 100);
        assertApproxRewardBal(cropsAdapter.reconciledAmt(alice), 0);
        divider.combine(address(cropsAdapter), newMaturity, ERC20(newYt).balanceOf(alice));
        assertApproxRewardBal(cropsAdapter.tBalance(alice), 0);
        assertApproxRewardBal(cropsAdapter.reconciledAmt(alice), 0);
        assertApproxRewardBal(cropsAdapter.tBalance(bob), (20 * tBal) / 100);
        assertApproxRewardBal(cropsAdapter.reconciledAmt(bob), (40 * tBal) / 100);
    }
    function testFuzzCantDiluteRewardsIfReconciledAndCombineS1_YTsFirstIV(uint256 tBal) public {
        assumeBounds(tBal);
        uint256 maturity = getValidMaturity(2021, 10);
        (, address yt) = periphery.sponsorSeries(address(cropsAdapter), maturity, true);
        uint256 newMaturity = getValidMaturity(2021, 11);
        (, address newYt) = periphery.sponsorSeries(address(cropsAdapter), newMaturity, true);
        divider.issue(address(cropsAdapter), maturity, (100 * tBal) / 100);
        assertApproxRewardBal(cropsAdapter.tBalance(alice), (100 * tBal) / 100);
        assertApproxRewardBal(cropsAdapter.reconciledAmt(alice), (0 * tBal) / 100);
        assertApproxRewardBal(ERC20(reward).balanceOf(alice), 0);
        divider.issue(address(cropsAdapter), newMaturity, (100 * tBal) / 100);
        assertApproxRewardBal(cropsAdapter.tBalance(alice), (200 * tBal) / 100);
        assertApproxRewardBal(cropsAdapter.reconciledAmt(alice), (0 * tBal) / 100);
        assertApproxRewardBal(ERC20(reward).balanceOf(alice), 0);
        reward.mint(address(cropsAdapter), 10 * 10**rDecimals);
        YT(yt).collect();
        assertApproxRewardBal(ERC20(reward).balanceOf(alice), 10 * 10**rDecimals);
        vm.warp(maturity + 1 seconds);
        divider.settleSeries(address(cropsAdapter), maturity);
        assertEq(cropsAdapter.tBalance(alice), (200 * tBal) / 100);
        assertEq(cropsAdapter.reconciledAmt(alice), 0);
        uint256[] memory maturities = new uint256[](1);
        maturities[0] = maturity;
        address[] memory users = new address[](2);
        users[0] = alice;
        cropsAdapter.reconcile(users, maturities);
        assertEq(cropsAdapter.tBalance(alice), (100 * tBal) / 100);
        assertEq(cropsAdapter.reconciledAmt(alice), (100 * tBal) / 100);
        divider.combine(address(cropsAdapter), maturity, ERC20(yt).balanceOf(alice));
        assertEq(cropsAdapter.tBalance(alice), (100 * tBal) / 100);
        assertEq(cropsAdapter.reconciledAmt(alice), 0);
        divider.combine(address(cropsAdapter), newMaturity, ERC20(newYt).balanceOf(alice));
        assertApproxRewardBal(cropsAdapter.tBalance(alice), (0 * tBal) / 100);
        assertApproxRewardBal(cropsAdapter.reconciledAmt(alice), (0 * tBal) / 100);
    }
    function testFuzzCantDiluteRewardsIfReconciledInProportionalDistributionWithScaleChanges(uint256 tBal) public {
        assumeBounds(tBal);
        uint256 maturity = getValidMaturity(2021, 10);
        (, address yt) = periphery.sponsorSeries(address(cropsAdapter), maturity, true);
        divider.issue(address(cropsAdapter), maturity, (60 * tBal) / 100); 
        vm.prank(bob);
        divider.issue(address(cropsAdapter), maturity, (40 * tBal) / 100); 
        reward.mint(address(cropsAdapter), 50 * 10**rDecimals);
        reward2.mint(address(cropsAdapter), 50 * 10**rDecimals);
        YT(yt).collect();
        vm.prank(bob);
        YT(yt).collect();
        assertApproxRewardBal(ERC20(reward).balanceOf(alice), 30 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward).balanceOf(bob), 20 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(alice), 30 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(bob), 20 * 10**rDecimals);
        is4626Target ? increaseScale(address(aTarget)) : cropsAdapter.setScale(2e18);
        assertEq(cropsAdapter.scale(), 2e18);
        reward.mint(address(cropsAdapter), 50 * 10**rDecimals);
        reward2.mint(address(cropsAdapter), 50 * 10**rDecimals);
        YT(yt).collect();
        vm.prank(bob);
        YT(yt).collect();
        assertApproxRewardBal(ERC20(reward).balanceOf(alice), 60 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(alice), 60 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward).balanceOf(bob), 40 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(bob), 40 * 10**rDecimals);
        reward.mint(address(cropsAdapter), 50 * 10**rDecimals);
        reward2.mint(address(cropsAdapter), 50 * 10**rDecimals);
        vm.warp(maturity + 1 seconds);
        divider.settleSeries(address(cropsAdapter), maturity);
        assertApproxRewardBal(cropsAdapter.reconciledAmt(alice), 0);
        assertApproxRewardBal(cropsAdapter.reconciledAmt(bob), 0);
        assertApproxRewardBal(cropsAdapter.tBalance(alice), (30 * tBal) / 100);
        assertApproxRewardBal(cropsAdapter.tBalance(bob), (20 * tBal) / 100);
        uint256[] memory maturities = new uint256[](1);
        maturities[0] = maturity;
        address[] memory users = new address[](2);
        users[0] = alice;
        users[1] = bob;
        cropsAdapter.reconcile(users, maturities);
        assertApproxRewardBal(cropsAdapter.tBalance(alice), 0);
        assertApproxRewardBal(cropsAdapter.tBalance(bob), 0);
        assertApproxRewardBal(cropsAdapter.reconciledAmt(alice), (30 * tBal) / 100);
        assertApproxRewardBal(cropsAdapter.reconciledAmt(bob), (20 * tBal) / 100);
        assertApproxRewardBal(ERC20(reward).balanceOf(alice), 90 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(alice), 90 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward).balanceOf(bob), 60 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(bob), 60 * 10**rDecimals);
        uint256 newMaturity = getValidMaturity(2021, 11);
        (, address newYt) = periphery.sponsorSeries(address(cropsAdapter), newMaturity, true);
        divider.issue(address(cropsAdapter), newMaturity, (60 * tBal) / 100);
        vm.prank(bob);
        divider.issue(address(cropsAdapter), newMaturity, (40 * tBal) / 100);
        assertApproxRewardBal(cropsAdapter.tBalance(alice), (60 * tBal) / 100);
        assertApproxRewardBal(cropsAdapter.tBalance(bob), (40 * tBal) / 100);
        assertApproxRewardBal(ERC20(reward).balanceOf(alice), 90 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(alice), 90 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward).balanceOf(bob), 60 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(bob), 60 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(alice), 90 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(bob), 60 * 10**rDecimals);
        reward.mint(address(cropsAdapter), 50 * 10**rDecimals);
        reward2.mint(address(cropsAdapter), 50 * 10**rDecimals);
        YT(yt).collect();
        vm.prank(bob);
        divider.issue(address(cropsAdapter), newMaturity, 0);
        assertApproxRewardBal(ERC20(reward).balanceOf(alice), 120 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward).balanceOf(bob), 80 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(alice), 120 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(bob), 80 * 10**rDecimals);
        divider.combine(address(cropsAdapter), maturity, ERC20(yt).balanceOf(alice));
        divider.combine(address(cropsAdapter), newMaturity, ERC20(newYt).balanceOf(alice));
        assertApproxRewardBal(cropsAdapter.reconciledAmt(alice), 0);
        vm.startPrank(bob);
        divider.combine(address(cropsAdapter), maturity, ERC20(yt).balanceOf(bob));
        divider.combine(address(cropsAdapter), newMaturity, ERC20(newYt).balanceOf(bob));
        vm.stopPrank();
        assertApproxRewardBal(cropsAdapter.reconciledAmt(bob), 0);
    }
    function testFuzzDiluteRewardsIfNoReconcile(uint256 tBal) public {
        assumeBounds(tBal);
        uint256 maturity = getValidMaturity(2021, 10);
        (, address yt) = periphery.sponsorSeries(address(cropsAdapter), maturity, true);
        divider.issue(address(cropsAdapter), maturity, (60 * tBal) / 100);
        vm.prank(bob);
        divider.issue(address(cropsAdapter), maturity, (40 * tBal) / 100);
        reward.mint(address(cropsAdapter), 50 * 10**rDecimals);
        reward2.mint(address(cropsAdapter), 50 * 10**rDecimals);
        YT(yt).collect();
        vm.prank(bob);
        YT(yt).collect();
        assertApproxRewardBal(ERC20(reward).balanceOf(alice), 30 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(alice), 30 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward).balanceOf(bob), 20 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(bob), 20 * 10**rDecimals);
        assertTrue(ERC20(yt).balanceOf(alice) > 0);
        assertTrue(cropsAdapter.tBalance(alice) > 0);
        vm.warp(maturity + 1 seconds);
        divider.settleSeries(address(cropsAdapter), maturity);
        vm.prank(bob);
        YT(yt).collect();
        assertEq(cropsAdapter.tBalance(bob), 0);
        assertEq(ERC20(yt).balanceOf(bob), 0);
        assertApproxEqAbs(ERC20(reward).balanceOf(address(cropsAdapter)), 0, 2);
        assertApproxEqAbs(ERC20(reward2).balanceOf(address(cropsAdapter)), 0, 2);
        uint256 newMaturity = getValidMaturity(2021, 11);
        (, address newYt) = periphery.sponsorSeries(address(cropsAdapter), newMaturity, true);
        vm.prank(bob);
        divider.issue(address(cropsAdapter), newMaturity, (40 * tBal) / 100);
        reward.mint(address(cropsAdapter), 50 * 10**rDecimals);
        reward2.mint(address(cropsAdapter), 50 * 10**rDecimals);
        vm.prank(bob);
        YT(newYt).collect();
        assertTrue(ERC20(reward).balanceOf(bob) != 70 * 10**rDecimals);
        assertTrue(ERC20(reward2).balanceOf(bob) != 70 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward).balanceOf(bob), 40 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(bob), 40 * 10**rDecimals);
        YT(yt).collect();
        assertApproxRewardBal(ERC20(reward).balanceOf(alice), 60 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(alice), 60 * 10**rDecimals);
        assertEq(cropsAdapter.tBalance(alice), 0);
        assertEq(ERC20(yt).balanceOf(alice), 0);
        assertEq(ERC20(yt).balanceOf(alice), 0);
    }
    function testFuzzDiluteRewardsIfLateReconcile(uint256 tBal) public {
        assumeBounds(tBal);
        uint256 maturity = getValidMaturity(2021, 10);
        (, address yt) = periphery.sponsorSeries(address(cropsAdapter), maturity, true);
        divider.issue(address(cropsAdapter), maturity, (60 * tBal) / 100);
        vm.prank(bob);
        divider.issue(address(cropsAdapter), maturity, (40 * tBal) / 100);
        reward.mint(address(cropsAdapter), 50 * 10**rDecimals);
        reward2.mint(address(cropsAdapter), 50 * 10**rDecimals);
        YT(yt).collect();
        vm.prank(bob);
        YT(yt).collect();
        assertApproxRewardBal(ERC20(reward).balanceOf(alice), 30 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(alice), 30 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward).balanceOf(bob), 20 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(bob), 20 * 10**rDecimals);
        assertTrue(ERC20(yt).balanceOf(alice) > 0);
        assertTrue(cropsAdapter.tBalance(alice) > 0);
        vm.warp(maturity + 1 seconds);
        divider.settleSeries(address(cropsAdapter), maturity);
        vm.prank(bob);
        YT(yt).collect();
        assertEq(cropsAdapter.tBalance(bob), 0);
        assertEq(ERC20(yt).balanceOf(bob), 0);
        assertApproxEqAbs(ERC20(reward).balanceOf(address(cropsAdapter)), 0, 2);
        assertApproxEqAbs(ERC20(reward2).balanceOf(address(cropsAdapter)), 0, 2);
        uint256 newMaturity = getValidMaturity(2021, 11);
        (, address newYt) = periphery.sponsorSeries(address(cropsAdapter), newMaturity, true);
        vm.prank(bob);
        divider.issue(address(cropsAdapter), newMaturity, (40 * tBal) / 100);
        reward.mint(address(cropsAdapter), 50 * 10**rDecimals);
        reward2.mint(address(cropsAdapter), 50 * 10**rDecimals);
        vm.prank(bob);
        YT(newYt).collect();
        assertTrue(ERC20(reward).balanceOf(bob) != 70 * 10**rDecimals);
        assertTrue(ERC20(reward2).balanceOf(bob) != 70 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward).balanceOf(bob), 40 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(bob), 40 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(bob), 40 * 10**rDecimals);
        assertEq(cropsAdapter.reconciledAmt(alice), 0);
        assertEq(cropsAdapter.tBalance(alice), (60 * tBal) / 100);
        uint256[] memory maturities = new uint256[](1);
        maturities[0] = maturity;
        address[] memory users = new address[](1);
        users[0] = alice;
        cropsAdapter.reconcile(users, maturities);
        assertEq(cropsAdapter.tBalance(alice), 0);
        assertEq(cropsAdapter.reconciledAmt(alice), (60 * tBal) / 100);
        assertApproxRewardBal(ERC20(reward).balanceOf(alice), 60 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(alice), 60 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(alice), 60 * 10**rDecimals);
        YT(yt).collect();
        assertApproxRewardBal(ERC20(reward).balanceOf(alice), 60 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(alice), 60 * 10**rDecimals);
        assertApproxRewardBal(ERC20(reward2).balanceOf(alice), 60 * 10**rDecimals);
        assertApproxRewardBal(ERC20(yt).balanceOf(alice), 0);
        assertEq(cropsAdapter.reconciledAmt(alice), 0);
    }
    function testFuzzReconcileSingleSeriesWhenTwoSeriesOverlap(uint256 tBal) public {
        assumeBounds(tBal);
        vm.warp(1609459200);
        uint256 maturity = getValidMaturity(2021, 12);
        (, address yt) = periphery.sponsorSeries(address(cropsAdapter), maturity, true);
        divider.issue(address(cropsAdapter), maturity, (60 * tBal) / 100);
        assertEq(reward.balanceOf(alice), 0);
        assertEq(reward2.balanceOf(alice), 0);
        reward.mint(address(cropsAdapter), 50 * 10**rDecimals);
        reward2.mint(address(cropsAdapter), 50 * 10**rDecimals);
        vm.warp(block.timestamp + 12 weeks); 
        uint256 newMaturity = getValidMaturity(2021, 7);
        (, address newYt) = periphery.sponsorSeries(address(cropsAdapter), newMaturity, true);
        divider.issue(address(cropsAdapter), newMaturity, 0);
        assertApproxRewardBal(reward.balanceOf(alice), 50 * 10**rDecimals);
        assertApproxRewardBal(reward2.balanceOf(alice), 50 * 10**rDecimals);
        vm.prank(bob);
        divider.issue(address(cropsAdapter), newMaturity, (40 * tBal) / 100);
        assertApproxRewardBal(reward.balanceOf(bob), 0);
        assertApproxRewardBal(reward2.balanceOf(bob), 0);
        reward.mint(address(cropsAdapter), 50 * 10**rDecimals);
        reward2.mint(address(cropsAdapter), 50 * 10**rDecimals);
        vm.warp(newMaturity + 1 seconds);
        divider.settleSeries(address(cropsAdapter), newMaturity);
        assertEq(cropsAdapter.reconciledAmt(alice), 0);
        assertEq(cropsAdapter.reconciledAmt(bob), 0);
        assertEq(cropsAdapter.tBalance(alice), (60 * tBal) / 100);
        assertEq(cropsAdapter.tBalance(bob), (40 * tBal) / 100);
        uint256[] memory maturities = new uint256[](1);
        maturities[0] = newMaturity;
        address[] memory users = new address[](2);
        users[0] = alice;
        users[1] = bob;
        cropsAdapter.reconcile(users, maturities);
        assertEq(cropsAdapter.tBalance(alice), (60 * tBal) / 100);
        assertEq(cropsAdapter.tBalance(bob), 0);
        assertEq(cropsAdapter.reconciledAmt(alice), 0);
        assertEq(cropsAdapter.reconciledAmt(bob), (40 * tBal) / 100);
        assertApproxRewardBal(reward.balanceOf(alice), 50 * 10**rDecimals);
        assertApproxRewardBal(reward2.balanceOf(alice), 50 * 10**rDecimals);
        assertApproxRewardBal(reward.balanceOf(bob), 20 * 10**rDecimals);
        assertApproxRewardBal(reward2.balanceOf(bob), 20 * 10**rDecimals);
        divider.issue(address(cropsAdapter), maturity, 0);
        assertApproxRewardBal(reward.balanceOf(alice), 80 * 10**rDecimals);
        assertApproxRewardBal(reward2.balanceOf(alice), 80 * 10**rDecimals);
    }
    function testAddRewardsTokens() public {
        MockToken reward3 = new MockToken("Reward Token 3", "RT3", 18);
        rewardTokens.push(address(reward3));
        vm.prank(address(cropsFactory)); 
        vm.expectEmit(true, false, false, false);
        emit RewardTokensChanged(rewardTokens);
        cropsAdapter.setRewardTokens(rewardTokens);
        assertEq(cropsAdapter.rewardTokens(0), address(reward));
        assertEq(cropsAdapter.rewardTokens(1), address(reward2));
        assertEq(cropsAdapter.rewardTokens(2), address(reward3));
    }
    function testRemoveRewardsTokens() public {
        address[] memory newRewardTokens = new address[](1);
        vm.expectEmit(true, false, false, false);
        emit RewardTokensChanged(newRewardTokens);
        vm.prank(address(cropsFactory)); 
        cropsAdapter.setRewardTokens(newRewardTokens);
        assertEq(cropsAdapter.rewardTokens(0), address(0));
    }
    function testCantSetRewardsTokens() public {
        MockToken reward2 = new MockToken("Reward Token 2", "RT2", 18);
        rewardTokens.push(address(reward2));
        vm.expectRevert("UNTRUSTED");
        cropsAdapter.setRewardTokens(rewardTokens);
    }
    function testCantSetClaimer(uint256 tBal) public {
        vm.expectRevert("UNTRUSTED");
        vm.prank(address(0x4b1d));
        cropsAdapter.setClaimer(address(cropsFactory));
    }
    function testCanSetClaimer(uint256 tBal) public {
        vm.expectEmit(true, true, true, true);
        emit ClaimerChanged(address(1));
        vm.prank(address(cropsFactory));
        cropsAdapter.setClaimer(address(1));
        assertEq(cropsAdapter.claimer(), address(1));
        vm.prank(Constants.RESTRICTED_ADMIN);
        adapter.setClaimer(address(2));
        assertEq(adapter.claimer(), address(2));
    }
    function testFuzzSimpleDistributionAndCollectWithClaimer(uint256 tBal) public {
        assumeBounds(tBal);
        uint256 maturity = getValidMaturity(2021, 10);
        (, address yt) = periphery.sponsorSeries(address(cropsAdapter), maturity, true);
        MockClaimer claimer = new MockClaimer(address(cropsAdapter), rewardTokens);
        vm.prank(Constants.RESTRICTED_ADMIN);
        cropsAdapter.setClaimer(address(claimer));
        divider.issue(address(cropsAdapter), maturity, (60 * tBal) / 100);
        vm.prank(bob);
        divider.issue(address(cropsAdapter), maturity, (40 * tBal) / 100);
        uint256 tBalBefore = ERC20(cropsAdapter.target()).balanceOf(address(cropsAdapter));
        assertEq(reward.balanceOf(bob), 0);
        assertEq(reward2.balanceOf(bob), 0);
        vm.prank(bob);
        YT(yt).collect();
        assertApproxRewardBal(reward.balanceOf(bob), 24 * 10**rDecimals);
        assertApproxRewardBal(reward2.balanceOf(bob), 24 * 1e6);
        uint256 tBalAfter = ERC20(cropsAdapter.target()).balanceOf(address(cropsAdapter));
        assertEq(tBalAfter, tBalBefore);
    }
    function testFuzzSimpleDistributionAndCollectWithClaimerReverts(uint256 tBal) public {
        assumeBounds(tBal);
        uint256 maturity = getValidMaturity(2021, 10);
        (, address yt) = periphery.sponsorSeries(address(cropsAdapter), maturity, true);
        MockClaimer claimer = new MockClaimer(address(cropsAdapter), rewardTokens);
        claimer.setTransfer(false); 
        vm.prank(Constants.RESTRICTED_ADMIN);
        cropsAdapter.setClaimer(address(claimer));
        divider.issue(address(cropsAdapter), maturity, (60 * tBal) / 100);
        vm.prank(bob);
        vm.expectRevert(abi.encodeWithSelector(Errors.BadContractInteration.selector));
        divider.issue(address(cropsAdapter), maturity, (40 * tBal) / 100);
    }
    function assumeBounds(uint256 tBal) internal {
        vm.assume(tBal > (10**(tDecimals - 1))); 
        vm.assume(tBal < MAX_TARGET / 3);
    }
    function assertApproxRewardBal(uint256 a, uint256 b) public {
        assertApproxEqAbs(a, b, 1500);
    }
    event Reconciled(address indexed usr, uint256 tBal, uint256 maturity);
    event ClaimerChanged(address indexed claimer);
    event Distributed(address indexed usr, address indexed token, uint256 amount);
    event RewardTokensChanged(address[] indexed rewardTokens);
    event RewardsClaimed(address indexed token, address indexed recipient, uint256 indexed amount);
}