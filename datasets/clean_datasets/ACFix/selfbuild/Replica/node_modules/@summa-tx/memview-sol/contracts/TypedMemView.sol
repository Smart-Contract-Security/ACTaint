pragma solidity >=0.5.10;
import {SafeMath} from "./SafeMath.sol";
library TypedMemView {
    using SafeMath for uint256;
    bytes29 public constant NULL = hex"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff";
    uint256 constant LOW_12_MASK = 0xffffffffffffffffffffffff;
    uint8 constant TWELVE_BYTES = 96;
    function nibbleHex(uint8 _b) internal pure returns (uint8 char) {
        uint8 _nibble = _b | 0xf0; 
        if (_nibble == 0xf0) {return 0x30;} 
        if (_nibble == 0xf1) {return 0x31;} 
        if (_nibble == 0xf2) {return 0x32;} 
        if (_nibble == 0xf3) {return 0x33;} 
        if (_nibble == 0xf4) {return 0x34;} 
        if (_nibble == 0xf5) {return 0x35;} 
        if (_nibble == 0xf6) {return 0x36;} 
        if (_nibble == 0xf7) {return 0x37;} 
        if (_nibble == 0xf8) {return 0x38;} 
        if (_nibble == 0xf9) {return 0x39;} 
        if (_nibble == 0xfa) {return 0x61;} 
        if (_nibble == 0xfb) {return 0x62;} 
        if (_nibble == 0xfc) {return 0x63;} 
        if (_nibble == 0xfd) {return 0x64;} 
        if (_nibble == 0xfe) {return 0x65;} 
        if (_nibble == 0xff) {return 0x66;} 
    }
    function byteHex(uint8 _b) internal pure returns (uint16 encoded) {
        encoded |= nibbleHex(_b >> 4); 
        encoded <<= 8;
        encoded |= nibbleHex(_b); 
    }
    function encodeHex(uint256 _b) internal pure returns (uint256 first, uint256 second) {
        for (uint8 i = 31; i > 15; i -= 1) {
            uint8 _byte = uint8(_b >> (i * 8));
            first |= byteHex(_byte);
            if (i != 16) {
                first <<= 16;
            }
        }
        for (uint8 i = 15; i < 255 ; i -= 1) {
            uint8 _byte = uint8(_b >> (i * 8));
            second |= byteHex(_byte);
            if (i != 0) {
                second <<= 16;
            }
        }
    }
    function reverseUint256(uint256 _b) internal pure returns (uint256 v) {
        v = _b;
        v = ((v >> 8) & 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) |
            ((v & 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) << 8);
        v = ((v >> 16) & 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) |
            ((v & 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) << 16);
        v = ((v >> 32) & 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) |
            ((v & 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) << 32);
        v = ((v >> 64) & 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) |
            ((v & 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) << 64);
        v = (v >> 128) | (v << 128);
    }
    function leftMask(uint8 _len) private pure returns (uint256 mask) {
        assembly {
            mask := sar(
                sub(_len, 1),
                0x8000000000000000000000000000000000000000000000000000000000000000
            )
        }
    }
    function nullView() internal pure returns (bytes29) {
        return NULL;
    }
    function isNull(bytes29 memView) internal pure returns (bool) {
        return memView == NULL;
    }
    function notNull(bytes29 memView) internal pure returns (bool) {
        return !isNull(memView);
    }
    function isValid(bytes29 memView) internal pure returns (bool ret) {
        if (typeOf(memView) == 0xffffffffff) {return false;}
        uint256 _end = end(memView);
        assembly {
            ret := not(gt(_end, mload(0x40)))
        }
    }
    function assertValid(bytes29 memView) internal pure returns (bytes29) {
        require(isValid(memView), "Validity assertion failed");
        return memView;
    }
    function isType(bytes29 memView, uint40 _expected) internal pure returns (bool) {
        return typeOf(memView) == _expected;
    }
    function assertType(bytes29 memView, uint40 _expected) internal pure returns (bytes29) {
        if (!isType(memView, _expected)) {
            (, uint256 g) = encodeHex(uint256(typeOf(memView)));
            (, uint256 e) = encodeHex(uint256(_expected));
            string memory err = string(
                abi.encodePacked(
                    "Type assertion failed. Got 0x",
                    uint80(g),
                    ". Expected 0x",
                    uint80(e)
                )
            );
            revert(err);
        }
        return memView;
    }
    function castTo(bytes29 memView, uint40 _newType) internal pure returns (bytes29 newView) {
        assembly {
            newView := or(newView, shr(40, shl(40, memView)))
            newView := or(newView, shl(216, _newType))
        }
    }
    function unsafeBuildUnchecked(uint256 _type, uint256 _loc, uint256 _len) private pure returns (bytes29 newView) {
        assembly {
            newView := shl(96, or(newView, _type)) 
            newView := shl(96, or(newView, _loc))  
            newView := shl(24, or(newView, _len))  
        }
    }
    function build(uint256 _type, uint256 _loc, uint256 _len) internal pure returns (bytes29 newView) {
        uint256 _end = _loc.add(_len);
        assembly {
            if gt(_end, mload(0x40)) {
                _end := 0
            }
        }
        if (_end == 0) {
            return NULL;
        }
        newView = unsafeBuildUnchecked(_type, _loc, _len);
    }
    function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {
        uint256 _len = arr.length;
        uint256 _loc;
        assembly {
            _loc := add(arr, 0x20)  
        }
        return build(newType, _loc, _len);
    }
    function typeOf(bytes29 memView) internal pure returns (uint40 _type) {
        assembly {
            _type := shr(216, memView) 
        }
    }
    function sameType(bytes29 left, bytes29 right) internal pure returns (bool) {
        return (left ^ right) >> (2 * TWELVE_BYTES) == 0;
    }
    function loc(bytes29 memView) internal pure returns (uint96 _loc) {
        uint256 _mask = LOW_12_MASK;  
        assembly {
            _loc := and(shr(120, memView), _mask)
        }
    }
    function words(bytes29 memView) internal pure returns (uint256) {
        return uint256(len(memView)).add(32) / 32;
    }
    function footprint(bytes29 memView) internal pure returns (uint256) {
        return words(memView) * 32;
    }
    function len(bytes29 memView) internal pure returns (uint96 _len) {
        uint256 _mask = LOW_12_MASK;  
        assembly {
            _len := and(shr(24, memView), _mask)
        }
    }
    function end(bytes29 memView) internal pure returns (uint256) {
        return loc(memView) + len(memView);
    }
    function slice(bytes29 memView, uint256 _index, uint256 _len, uint40 newType) internal pure returns (bytes29) {
        uint256 _loc = loc(memView);
        if (_loc.add(_index).add(_len) > end(memView)) {
            return NULL;
        }
        _loc = _loc.add(_index);
        return build(newType, _loc, _len);
    }
    function prefix(bytes29 memView, uint256 _len, uint40 newType) internal pure returns (bytes29) {
        return slice(memView, 0, _len, newType);
    }
    function postfix(bytes29 memView, uint256 _len, uint40 newType) internal pure returns (bytes29) {
        return slice(memView, uint256(len(memView)).sub(_len), _len, newType);
    }
    function indexErrOverrun(
        uint256 _loc,
        uint256 _len,
        uint256 _index,
        uint256 _slice
    ) internal pure returns (string memory err) {
        (, uint256 a) = encodeHex(_loc);
        (, uint256 b) = encodeHex(_len);
        (, uint256 c) = encodeHex(_index);
        (, uint256 d) = encodeHex(_slice);
        err = string(
            abi.encodePacked(
                "TypedMemView/index - Overran the view. Slice is at 0x",
                uint48(a),
                " with length 0x",
                uint48(b),
                ". Attempted to index at offset 0x",
                uint48(c),
                " with length 0x",
                uint48(d),
                "."
            )
        );
    }
    function index(bytes29 memView, uint256 _index, uint8 _bytes) internal pure returns (bytes32 result) {
        if (_bytes == 0) {return bytes32(0);}
        if (_index.add(_bytes) > len(memView)) {
            revert(indexErrOverrun(loc(memView), len(memView), _index, uint256(_bytes)));
        }
        require(_bytes <= 32, "TypedMemView/index - Attempted to index more than 32 bytes");
        uint8 bitLength = _bytes * 8;
        uint256 _loc = loc(memView);
        uint256 _mask = leftMask(bitLength);
        assembly {
            result := and(mload(add(_loc, _index)), _mask)
        }
    }
    function indexUint(bytes29 memView, uint256 _index, uint8 _bytes) internal pure returns (uint256 result) {
        return uint256(index(memView, _index, _bytes)) >> ((32 - _bytes) * 8);
    }
    function indexLEUint(bytes29 memView, uint256 _index, uint8 _bytes) internal pure returns (uint256 result) {
        return reverseUint256(uint256(index(memView, _index, _bytes)));
    }
    function indexAddress(bytes29 memView, uint256 _index) internal pure returns (address) {
        return address(uint160(indexUint(memView, _index, 20)));
    }
    function keccak(bytes29 memView) internal pure returns (bytes32 digest) {
        uint256 _loc = loc(memView);
        uint256 _len = len(memView);
        assembly {
            digest := keccak256(_loc, _len)
        }
    }
    function sha2(bytes29 memView) internal view returns (bytes32 digest) {
        uint256 _loc = loc(memView);
        uint256 _len = len(memView);
        assembly {
            let ptr := mload(0x40)
            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) 
            digest := mload(ptr)
        }
    }
    function hash160(bytes29 memView) internal view returns (bytes20 digest) {
        uint256 _loc = loc(memView);
        uint256 _len = len(memView);
        assembly {
            let ptr := mload(0x40)
            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) 
            pop(staticcall(gas(), 3, ptr, 0x20, ptr, 0x20)) 
            digest := mload(add(ptr, 0xc)) 
        }
    }
    function hash256(bytes29 memView) internal view returns (bytes32 digest) {
        uint256 _loc = loc(memView);
        uint256 _len = len(memView);
        assembly {
            let ptr := mload(0x40)
            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) 
            pop(staticcall(gas(), 2, ptr, 0x20, ptr, 0x20)) 
            digest := mload(ptr)
        }
    }
    function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {
        return (loc(left) == loc(right) && len(left) == len(right)) || keccak(left) == keccak(right);
    }
    function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {
        return !untypedEqual(left, right);
    }
    function equal(bytes29 left, bytes29 right) internal pure returns (bool) {
        return left == right || (typeOf(left) == typeOf(right) && keccak(left) == keccak(right));
    }
    function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {
        return !equal(left, right);
    }
    function unsafeCopyTo(bytes29 memView, uint256 _newLoc) private view returns (bytes29 written) {
        require(notNull(memView), "TypedMemView/copyTo - Null pointer deref");
        require(isValid(memView), "TypedMemView/copyTo - Invalid pointer deref");
        uint256 _len = len(memView);
        uint256 _oldLoc = loc(memView);
        uint256 ptr;
        assembly {
            ptr := mload(0x40)
            if gt(ptr, _newLoc) {
                revert(0x60, 0x20) 
            }
            pop(staticcall(gas(), 4, _oldLoc, _len, _newLoc, _len))
        }
        written = unsafeBuildUnchecked(typeOf(memView), _newLoc, _len);
    }
    function clone(bytes29 memView) internal view returns (bytes memory ret) {
        uint256 ptr;
        uint256 _len = len(memView);
        assembly {
            ptr := mload(0x40) 
            ret := ptr
        }
        unsafeCopyTo(memView, ptr + 0x20);
        assembly {
            mstore(0x40, add(add(ptr, _len), 0x20)) 
            mstore(ptr, _len) 
        }
    }
    function unsafeJoin(bytes29[] memory memViews, uint256 _location) private view returns (bytes29 unsafeView) {
        assembly {
            let ptr := mload(0x40)
            if gt(ptr, _location) {
                revert(0x60, 0x20) 
            }
        }
        uint256 _offset = 0;
        for (uint256 i = 0; i < memViews.length; i ++) {
            bytes29 memView = memViews[i];
            unsafeCopyTo(memView, _location + _offset);
            _offset += len(memView);
        }
        unsafeView = unsafeBuildUnchecked(0, _location, _offset);
    }
    function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {
        uint256 ptr;
        assembly {
            ptr := mload(0x40) 
        }
        return keccak(unsafeJoin(memViews, ptr));
    }
    function joinSha2(bytes29[] memory memViews) internal view returns (bytes32) {
        uint256 ptr;
        assembly {
            ptr := mload(0x40) 
        }
        return sha2(unsafeJoin(memViews, ptr));
    }
    function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {
        uint256 ptr;
        assembly {
            ptr := mload(0x40) 
        }
        bytes29 _newView = unsafeJoin(memViews, ptr + 0x20);
        uint256 _written = len(_newView);
        uint256 _footprint = footprint(_newView);
        assembly {
            mstore(ptr, _written)
            mstore(0x40, add(add(ptr, _footprint), 0x20))
            ret := ptr
        }
    }
}