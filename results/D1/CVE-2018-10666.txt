Solidity Version: 0.4.19
Switched global version to 0.4.19
==============Start====================
rules:
{Function:setOwner, Visibility:public, Explanation:Writes to variable owner without any access control.}

=============Contract: Owned
Sink:
Step 2: **Identify Sink**

Let's analyze the provided smart contract code to identify any Sink operations:

1. **Constructor Function:**
   - The function `Owned()` is the constructor. This is intended to set the initial owner of the contract and doesn't require further access control analysis as it is only called during contract deployment.

2. **Function `setOwner`:**
   - The `setOwner` function allows changing the `owner` state variable.
   - This function has no access control mechanism implemented (e.g., `onlyOwner` modifier), which means it can be called by anyone.
   - Given the static analysis reference, `setOwner` has been identified as a potential vulnerability since it can be invoked publicly and can alter the ownership of the contract without restrictions.

3. **Modifier `onlyOwner`:**
   - The modifier `onlyOwner` is correctly implemented, ensuring that only the current owner can execute the functions it modifies. However, it is not used in the `setOwner` function.

No other potential sinks are present since there are no cryptographic operations or payment-based ownership transfer mechanisms in the code.

Step 3: **Self-Evaluate and Explain**

Based on the analysis:

- The `setOwner` function is identified as a sink due to its lack of access control. It allows arbitrary users to change the owner of the contract, which is a critical security risk.

Here is the formal explanation:

--Sink--:
{Function: setOwner, Sink: Assignment to owner, Visibility: public, Explanation: The function allows public access to change the contract owner without any access control, leading to potential unauthorized ownership change.}
Report:
Step 1: **Taint Source Analysis**

- **Function: setOwner**:
  - Taint Source: The function parameter `_owner` can be considered a potential taint source as it is provided by the caller of the function.
  - The function has `public` visibility, meaning any external account can invoke it, making `_owner` an untrusted input.

Step 2: **Taint Propagation Path**

- **Function: setOwner**:
  - Taint Path: `_owner` is directly assigned to the `owner` state variable without any access control checks, such as a `require` statement or modifier.
  - The function lacks any conditional checks or cryptographic operations that would prevent unauthorized inputs from influencing the assignment.
  - Although the contract includes a modifier `onlyOwner`, this modifier is not applied to the `setOwner` function, allowing the function to be executed by any account, effectively making the `owner` assignment vulnerable to unauthorized change.

Step 3: **Self-Evaluation**

Upon analyzing the taint propagation path, it is evident that there is a direct path from the untrusted input (`_owner` parameter) to the sensitive operation (assignment to `owner`). The absence of any access control mechanisms in the `setOwner` function exposes the contract to unauthorized ownership change, which is a significant access control vulnerability.

--Vulnerability--:
{Function:setOwner,Taint Path:_owner parameter directly assigned to owner,Description:Public access allows unauthorized change of contract ownership}

rules:
{Function:approveAndCall, Visibility:public, Explanation:Writes to variable allowance without any access control.}
{Function:precalculate, Visibility:internal, Explanation:Writes to variable singleIDXMQty without any access control.}

=============Contract: IDXM
Sink:
To identify sinks in the provided smart contract code, we will examine each function for any security-sensitive operations that may lead to access control vulnerabilities. We will pay particular attention to functions that modify critical state variables without proper access controls or that may be executed by unauthorized parties.

1. **Constructor Function**:
   - The `IDXM` function is the constructor, initializing the contract state, setting the total supply, and assigning it to the contract deployer. It is correctly protected as it can only be executed once during contract deployment. Thus, it is not a sink.

2. **Standard Functions**:
   - `transfer`, `transferFrom`, and `approve`: These functions operate similarly to standard ERC-20 functions and include checks to ensure the sender has enough balance and, where applicable, that the spender is approved. They modify the caller's state or require approval, so they are not considered sinks.
   - `approveAndCall`: This function allows for calling another contract with an approval. Although it involves interacting with another contract, it requires approval from the message sender and thus is not inherently a sink.

3. **Non-Standard Functions**:
   - `uploadBalances`: This function updates balances of multiple addresses and can only be executed by the contract owner due to the `onlyOwner` modifier. Although it modifies the state, it is controlled by ownership and thus is not a sink.
   - `lockBalances`: This function also requires `onlyOwner`, meaning it cannot be called by unauthorized parties, avoiding sink classification.
   - `setExportFee`, `setHoldingPeriod`, and `unlockToken`: These functions change contract parameters and require `onlyOwner`, ensuring they are executed by the owner, preventing them from being sinks.
   - `precalculate`: This internal function modifies `baseFeeDivisor`, `feeDivisor`, and `singleIDXMQty`. It does not involve direct external access or authorization issues and is executed as part of the constructor. It does not qualify as a sink.

4. **Functionality Without Proper Access Control**:
   - The reference mentions that the `approveAndCall` function writes to the allowance mapping without access control concerns. However, it follows standard patterns and involves approval from the caller, so it is not a sink.
   - No other functionality in this contract is executed without appropriate checks or owner restrictions, indicating no additional sinks.

After evaluating all functions, considering modifiers, and the context in which they operate, the analysis concludes as follows:

--Sink--: 
no sinks
Report:

==============End======================
total time: 15.70772910118103
total token: 6264