Solidity Version: 0.4.22
Switched global version to 0.4.22
==============Start====================
rules:
{Function:fallback, Visibility:external, Explanation:Writes to variable balances without any access control.}
{Function:XBornID, Visibility:public, Explanation:Writes to variable balances without any access control.}
{Function:fallback, Visibility:external, Explanation:Writes to variable distributionFinished without any access control.}
{Function:XBornID, Visibility:public, Explanation:Writes to variable owner without any access control.}
{Function:fallback, Visibility:external, Explanation:Writes to variable value without any access control.}
{Function:fallback, Visibility:external, Explanation:Writes to variable totalRemaining without any access control.}
{Function:fallback, Visibility:external, Explanation:Writes to variable totalDistributed without any access control.}
{Function:fallback, Visibility:external, Explanation:Writes to variable blacklist without any access control.}
{Function:withdraw, Visibility:public, Explanation:Transfers Ether or Token.}
{Function:withdrawForeignTokens, Visibility:public, Explanation:Transfers Ether or Token.}

=============Contract: XBORNID
Sink:
To identify sink operations in the provided contract, we need to examine the code for any functions or operations that can cause access control vulnerabilities due to inadequate restrictions. We will follow the reference guidelines and analyze the operations carefully:

1. **Fallback Function**:
   - The fallback function is defined as `function () external payable`, which calls the `getTokens()` function.
   - The `getTokens()` function involves operations that change the state, such as updating balances, totalDistributed, totalRemaining, value, and modifying the blacklist. However, it is protected by the `canDistr` and `onlyWhitelist` modifiers, which enforce checks before the function is executed. The `canDistr` modifier ensures that distribution is not finished, and the `onlyWhitelist` modifier ensures that the caller is not blacklisted.

2. **XBornID Function (Constructor)**:
   - Although the function is written in the constructor style, the constructor is not using the correct naming style in Solidity 0.4.22 and beyond. The constructor should be named using the `constructor()` keyword. Therefore, this function is misclassified as a constructor and can be invoked by anyone.
   - The function writes to the `balances` mapping by assigning `totalDistributed` to the `owner` and sets the `owner` address. This lack of proper access control indicates a security-sensitive operation.

3. **Withdraw Function**:
   - The `withdraw()` function is protected by the `onlyOwner` modifier, allowing only the owner to withdraw the contract's Ether balance. This protection is sufficient, and the operation is not considered a sink.

4. **WithdrawForeignTokens Function**:
   - The `withdrawForeignTokens()` function allows the owner to transfer all tokens of another contract owned by this contract to themselves. This is a high-risk operation, but it is protected by the `onlyOwner` modifier, which limits access to the owner only.

5. **Burn Function**:
   - The `burn()` function decreases the caller's balance and totalSupply, and is also protected by the `onlyOwner` modifier. This ensures that only the owner can burn tokens, thus it is not considered a sink.

After analyzing the contract, the operations that present potential security risks due to access control issues are identified as follows:

--Sink--:
{Function: XBornID, Sink: Write to balances and owner, Visibility: public, Explanation: The function acts as a constructor but lacks proper access control, allowing anyone to invoke it and alter the initial state.}

Report:
To analyze the contract for potential access control vulnerabilities, we follow the outlined steps:

### Step 1: Taint Source Identification

The identified sink is within the function `XBornID`, which acts as a constructor. The potential taint source is `msg.sender`, as it can influence the state by writing to `balances` and `owner`.

### Step 2: Taint Propagation Path Analysis

- **Function: `XBornID`**  
  - **Visibility:** `public`  
  - **Potential Taint Source:** `msg.sender` can invoke this function as it lacks proper access control mechanisms such as a constructor identifier or access modifiers like `onlyOwner`.
  - **Impact:** 
    - This allows any user to call `XBornID` and reset the `owner` to themselves, which can affect subsequent access-controlled functions. 
    - It also initializes `balances[owner]` with `totalDistributed`, which could lead to unauthorized balance setting.

The path from `msg.sender` is direct and unhindered, resulting in access control issues due to lack of protection.

### Step 3: Self-Evaluation

Given the analysis, there exists a direct taint path from `msg.sender` to the identified sink due to lack of proper constructor access control. This constitutes an access control vulnerability, as the state initialization can be influenced by any user.

--Vulnerability--:
{Function:XBornID,Taint Path:msg.sender->XBornID(),Description:The function acts as a constructor but lacks proper access control, allowing anyone to invoke it and alter the initial state by changing owner and setting initial balances.}

No other taint paths from untrusted sources to security-sensitive operations were detected in the contract.

==============End======================
total time: 12.277233123779297
total token: 5644