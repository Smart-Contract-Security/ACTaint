Solidity Version: 0.4.18
Switched global version to 0.4.18
==============Start====================
rules:
{Function:owned, Visibility:public, Explanation:Writes to variable owner without any access control.}

=============Contract: Owned
Sink:
To identify potential sinks in the provided smart contract code, we will follow the steps outlined:

### Step 1: Reference Analysis
The static analysis result indicates that the `owned` function is public and writes to the `owner` variable without any access control. This is a potential security risk because it allows any user to set the owner of the contract.

### Step 2: Identify Sink
Let's analyze each function in the contract to identify any sink operations:

1. **Function: `owned`**
   - **Visibility**: Public
   - **Operation**: Sets the `owner` variable to `msg.sender`.
   - **Access Control**: None
   - **Analysis**: This function is intended to act as a constructor or initializer, but it is not protected by any access control. This means any user can call this function and set themselves as the owner of the contract. This is a clear access control vulnerability.

2. **Function: `transferOwnership`**
   - **Visibility**: Public
   - **Operation**: Transfers ownership to a new address.
   - **Access Control**: Protected by the `onlyOwner` modifier.
   - **Analysis**: The `onlyOwner` modifier ensures that only the current owner can call this function. Therefore, this function is not a sink because it has proper access control.

### Step 3: Self-Evaluate and Explain
Based on the analysis, the `owned` function is identified as a sink due to its lack of access control, allowing any user to set the contract owner.

--Sink--:
{Function: owned, Sink: owner assignment, Visibility: public, Explanation: The function allows any user to set themselves as the owner of the contract without any access control, leading to a potential access control vulnerability.}
Report:
To analyze the provided contract for potential vulnerabilities, we will follow the outlined steps:

### Step 1: Taint Source Identification

- **Function: `owned`**
  - **Sink**: Assignment of `owner` to `msg.sender`.
  - **Visibility**: Public.
  - **Taint Source**: `msg.sender` is an untrusted input because any external account can call this function.

### Step 2: Taint Propagation Path

- **Function: `owned`**
  - **Taint Path**: The function `owned` is publicly accessible and can be called by any external account. This means `msg.sender` directly influences the assignment to `owner` without any access control checks.
  - **Access Control**: There are no access control mechanisms (such as `require` statements or modifiers) in place to restrict who can call the `owned` function. This allows any user to set themselves as the owner of the contract.

### Step 3: Self-Evaluation

- **Access Control Vulnerability**: The lack of access control in the `owned` function allows any user to become the owner of the contract. This is a clear access control vulnerability because it allows unauthorized users to gain control over the contract.

Based on the analysis, the following vulnerability is identified:

--Vulnerability--:
{Function: owned, Taint Path: msg.sender -> owner, Description: The `owned` function allows any user to set themselves as the owner of the contract without any access control, leading to a potential access control vulnerability.}

rules:
{Function:approve, Visibility:public, Explanation:Writes to variable allowed without any access control.}

=============Contract: ERC20
Sink:
To identify potential sinks in the provided ERC20 contract, we will analyze each function for security-sensitive operations that may lead to access control vulnerabilities.

### Step-by-Step Analysis:

1. **Constructor Function:**
   - **Function:** `ERC20(uint256 _initialSupply, string _tokenName, string _tokenSymbol)`
   - **Visibility:** Public
   - **Explanation:** This function is correctly identified as the constructor. It initializes the total supply and assigns it to the contract deployer. It does not present a sink as it is intended to be called only once during contract deployment.

2. **Transfer Function:**
   - **Function:** `transfer(address _to, uint256 _value)`
   - **Visibility:** Public
   - **Explanation:** This function implements a standard ERC20 transfer operation. It includes checks to prevent transfers from or to blacklisted accounts and ensures sufficient balance. It does not modify any state without proper checks, so it is not a sink.

3. **TransferFrom Function:**
   - **Function:** `transferFrom(address _from, address _to, uint256 _amount)`
   - **Visibility:** Public
   - **Explanation:** This function allows transferring tokens on behalf of another address, given sufficient allowance. It checks for balance and allowance before proceeding, which is standard for ERC20 tokens. It does not present a sink.

4. **Approve Function:**
   - **Function:** `approve(address _spender, uint256 _amount)`
   - **Visibility:** Public
   - **Explanation:** This function sets the allowance for a spender. The static analysis result indicates that it writes to the `allowed` mapping without additional access control. However, this is standard behavior for ERC20 tokens, where the owner of the tokens sets the allowance. Therefore, it is not considered a sink.

5. **Allowance Function:**
   - **Function:** `allowance(address _owner, address _spender)`
   - **Visibility:** Public
   - **Explanation:** This function returns the remaining allowance for a spender. It is a read-only function and does not modify any state, so it is not a sink.

### Conclusion:

After analyzing the contract, no functions were identified as sinks. The operations performed in each function are standard for ERC20 tokens and include necessary checks to prevent unauthorized access or state modification.

--Sink--: 
no sinks
Report:

==============End======================
total time: 70.94166588783264
total token: 5487