Solidity Version: 0.4.24
Switched global version to 0.4.24
==============Start====================
rules:
{Function:EAI_TokenERC20, Visibility:public, Explanation:Writes to variable balanceOf without any access control.}
{Function:transfer, Visibility:public, Explanation:Writes to variable balanceOf without any access control.}

=============Contract: EAI_TokenERC
Sink:
To identify sinks in the given contract, we will analyze each function step by step, evaluating potential access control issues and any security-sensitive operations:

1. **EAI_TokenERC20 Function**: 
   - This function acts as a constructor since it initializes important state variables such as `totalSupply`, `balanceOf`, `name`, and `symbol`.
   - In Solidity, constructors are indicated by the `constructor` keyword, and since this contract does not have a proper constructor definition, this function is susceptible to being called by anyone after contract deployment.
   - **Sink**: The function is public and can be used to reinitialize the contract, effectively resetting the token supply and reassigning all tokens to the caller.

2. **_transfer Function**:
   - This is an internal function used to move tokens between accounts.
   - It contains require statements to ensure token balances are valid and performs arithmetic operations on `balanceOf`.
   - There is no direct access control concern here because the function is called by other functions that manage access.

3. **transfer Function**:
   - This function allows a sender to transfer tokens to another account.
   - It calls the internal `_transfer` function and modifies the sender's (`msg.sender`) balance.
   - Since it operates on the caller's tokens and implements standard checks, it does not introduce unauthorized access issues.

4. **transferFrom Function**:
   - This function allows an approved spender to transfer tokens on behalf of another account.
   - It includes checks for the allowance and balance, ensuring that it operates within permitted limits.
   - The function follows standard ERC-20 practice, and thus, does not pose an access control risk.

5. **burn Function**:
   - This function allows the caller to destroy their own tokens, reducing the total supply.
   - Since it only modifies the caller's (`msg.sender`) balance, it does not raise an access control issue.

6. **burnFrom Function**:
   - This function allows burning tokens from an account, subject to an allowance given to the caller.
   - The allowance check and the balance requirement ensure that only authorized burns are executed.
   - This follows standard practice, posing no unauthorized access risk.

### Conclusion:

After careful analysis, the only function identified as a sink is the `EAI_TokenERC20` function due to its potential to reinitialize critical contract state variables without proper access control. The remaining functions follow standard ERC-20 practices and do not introduce access control vulnerabilities.

--Sink--:
{Function: EAI_TokenERC20, Sink: Function Initialization, Visibility: public, Explanation: This function acts as a constructor, allowing anyone to reinitialize contract state variables, thus compromising access control.}
Report:
**Step 1: Taint Source Identification**

In the provided contract `EAI_TokenERC`, the identified sink is the function `EAI_TokenERC20`, which acts like a constructor due to the matching contract name and has `public` visibility. This is unusual as constructors in Solidity should have the `constructor` keyword and not `public` visibility in modern Solidity versions. This function can be influenced by untrusted inputs as it accepts parameters directly from the caller. These parameters are `initialSupply`, `tokenName`, and `tokenSymbol`, which are directly set in the contract state. The lack of a proper constructor allows anyone to call this function.

**Step 2: Taint Propagation Path Analysis**

Let's perform the taint analysis:

1. **Function: `EAI_TokenERC20`**
   - **Parameters**: `initialSupply`, `tokenName`, `tokenSymbol` (all tainted since they are from an external caller)
   - **Influence**: These parameters directly influence the state variables `totalSupply`, `name`, and `symbol`.
   - **Access Control**: There is no access control mechanism (e.g., `require` statement) within the `EAI_TokenERC20` function to prevent unauthorized access, meaning any address can call this function and reinitialize the contract state variables, effectively compromising the intended initial settings of the token, including total supply and the name and symbol of the token.

Given these details, the lack of access control in this initializer function allows any user to modify the contract's initial settings, posing a security risk.

**Step 3: Self-Evaluation**

Based on the analysis, a taint path exists from untrusted inputs to the security-sensitive operations in the function `EAI_TokenERC20`, resulting in an access control vulnerability. The vulnerability stems from the fact that any user can call this function and reset the contract's state variables, thus compromising the contract's integrity.

--Vulnerability--:
{Function:EAI_TokenERC20, Taint Path: Parameters (initialSupply, tokenName, tokenSymbol), Description: Lack of access control allows reinitialization of contract state by any user, compromising access control and token integrity.}

==============End======================
total time: 15.67502474784851
total token: 4451