Solidity Version: 0.4.24
Switched global version to 0.4.24
==============Start====================
rules:
{Function:releaseTokensTo, Visibility:internal, Explanation:Writes to variable remainingTokens without any access control.}
{Function:releaseTokensTo, Visibility:internal, Explanation:Writes to variable soldTokens without any access control.}
{Function:setTimeRC, Visibility:internal, Explanation:Writes to variable endTime without any access control.}
{Function:setTimeRC, Visibility:internal, Explanation:Writes to variable startTime without any access control.}
{Function:releaseTokensTo, Visibility:internal, Explanation:Writes to variable pendingTokenUser without any access control.}
{Function:releaseTokensTo, Visibility:internal, Explanation:Writes to variable tokenUser without any access control.}
{Function:withdraw, Visibility:public, Explanation:Transfers Ether or Token.}
{Function:giveToken, Visibility:internal, Explanation:Transfers Ether or Token.}
{Function:refundEther, Visibility:public, Explanation:Transfers Ether or Token.}
{Function:takeEther, Visibility:internal, Explanation:Transfers Ether or Token.}
{Function:claimTokenBonus, Visibility:internal, Explanation:Transfers Ether or Token.}

=============Contract: RC
Sink:
To identify the **Sink** operations in the provided smart contract, we will analyze each function and operation that could potentially lead to access control vulnerabilities. We will focus on operations that transfer Ether or tokens, modify critical state variables, or perform actions that should be restricted to authorized users.

### Step-by-Step Analysis:

1. **Constructor Function:**
   - The function `RC` is the constructor and is correctly defined as such. It initializes the contract state and sets up the initial parameters. Constructors are not considered sinks as they are only called once during contract deployment.

2. **Function `setTime`:**
   - This function modifies `startTime` and `endTime` and is protected by the `onlyTokenSaleOwner` modifier, which ensures that only the owner of the `tokenSaleContract` can call it. This is not a sink due to proper access control.

3. **Function `changeMinimum`:**
   - This function modifies `etherMinimum` and is also protected by the `onlyTokenSaleOwner` modifier. It is not a sink due to proper access control.

4. **Function `releaseTokensTo`:**
   - This function calls `takeEther` and `giveToken`, both of which involve transferring tokens and Ether. However, `releaseTokensTo` is an internal function and is not directly accessible externally, thus not a sink by itself.

5. **Function `takeEther`:**
   - This function transfers Ether back to the buyer if there is a refund. It is an internal function and is called within the contract logic, ensuring it is not directly accessible externally. However, it involves transferring Ether, which is a sensitive operation.

6. **Function `giveToken`:**
   - This function transfers tokens to the buyer and then transfers Ether to the `tokenSaleContract` wallet. It is an internal function and is called within the contract logic, ensuring it is not directly accessible externally. However, it involves transferring Ether and tokens, which are sensitive operations.

7. **Function `claimTokenBonus`:**
   - This function transfers additional tokens as a bonus to the buyer and refunds any Ether sent with the transaction. It is an internal function and is called within the contract logic, ensuring it is not directly accessible externally. However, it involves transferring tokens and Ether, which are sensitive operations.

8. **Function `refundEther`:**
   - This function transfers Ether back to a specified address and is protected by the `onlyTokenSaleOwner` modifier. It is not a sink due to proper access control.

9. **Function `withdraw`:**
   - This function transfers a specified amount of Ether to a specified address and is protected by the `onlyTokenSaleOwner` modifier. It is not a sink due to proper access control.

10. **Fallback Function:**
    - The fallback function allows Ether to be sent to the contract and calls `takeEther` or `claimTokenBonus` based on the current time. It requires the current time to be within the sale period, providing some level of control.

### Conclusion:

After analyzing the contract, the following operations are identified as **Sinks** due to their involvement in transferring Ether or tokens, which are sensitive operations:

--Sink--:
{Function: takeEther, Sink: Ether Transfer, Visibility: internal, Explanation: Transfers Ether back to the buyer if there is a refund.}
{Function: giveToken, Sink: Ether and Token Transfer, Visibility: internal, Explanation: Transfers tokens to the buyer and Ether to the tokenSaleContract wallet.}
{Function: claimTokenBonus, Sink: Ether and Token Transfer, Visibility: internal, Explanation: Transfers additional tokens as a bonus and refunds Ether.}

These functions are internal and are called within the contract logic, but they involve sensitive operations that require careful handling to prevent unauthorized access or misuse.
Report:
To analyze the contract for potential vulnerabilities, we will follow the steps outlined:

### Step 1: Taint Source Identification

1. **Function: `takeEther`**
   - **Sink**: Ether Transfer
   - **Visibility**: Internal
   - **Untrusted Inputs**: `msg.sender` (indirectly through the fallback function)

2. **Function: `giveToken`**
   - **Sink**: Ether and Token Transfer
   - **Visibility**: Internal
   - **Untrusted Inputs**: `msg.sender` (indirectly through `releaseTokensTo`)

3. **Function: `claimTokenBonus`**
   - **Sink**: Ether and Token Transfer
   - **Visibility**: Internal
   - **Untrusted Inputs**: `msg.sender` (indirectly through the fallback function)

### Step 2: Taint Propagation Path Analysis

1. **Function: `takeEther`**
   - **Path**: The fallback function `function () public payable` can be called by any external account (`msg.sender` is untrusted). It calls `takeEther(msg.sender)`.
   - **Access Control**: The function checks `now > startTime`, `now < endTime`, `msg.value >= etherMinimum`, and `remainingTokens > 0`. These are time and state-based conditions, not access control mechanisms.
   - **Conclusion**: The function can be called by any user during the specified time window, but this is intended behavior for a token sale.

2. **Function: `giveToken`**
   - **Path**: Called internally by `releaseTokensTo`, which is called by the fallback function if `msg.value > 0`.
   - **Access Control**: The function checks `pendingTokenUser[_buyer] > 0`. This is a state-based condition.
   - **Conclusion**: The function is intended to be called as part of the token sale process, and the checks ensure that tokens are only given if there are pending tokens.

3. **Function: `claimTokenBonus`**
   - **Path**: The fallback function can call `claimTokenBonus(msg.sender)` if `now >= endTime`.
   - **Access Control**: The function checks `now > endTime` and `tokenUser[_buyer] > 0`. These are time and state-based conditions.
   - **Conclusion**: The function is intended to be called after the token sale ends to distribute bonuses, and the checks ensure that bonuses are only given if the user has tokens.

### Step 3: Self-Evaluation

- **Function: `takeEther`**: The function is designed to allow users to participate in the token sale by sending Ether. The conditions ensure that the sale is active and the user sends enough Ether. This is intended behavior.
- **Function: `giveToken`**: The function is part of the token distribution process and is protected by state-based checks. This is intended behavior.
- **Function: `claimTokenBonus`**: The function is designed to distribute bonuses after the sale ends, with appropriate checks. This is intended behavior.

### Conclusion

The contract is designed to handle a token sale, and the functions are intended to be called by users participating in the sale. The conditions in place are state and time-based, ensuring the correct operation of the sale process. There are no access control vulnerabilities as the functions are operating as intended within the context of a token sale.

--Vulnerability--: 
no vulnerability

rules:
{Function:claim, Visibility:public, Explanation:Transfers Ether or Token.}
{Function:withdrawTokens, Visibility:public, Explanation:Transfers Ether or Token.}
{Function:forward, Visibility:internal, Explanation:Transfers Ether or Token.}
{Function:withdraw, Visibility:public, Explanation:Transfers Ether or Token.}
{Function:buyFromRC, Visibility:public, Explanation:Transfers Ether or Token.}

=============Contract: TokenSale
Sink:
To identify the sink operations in the provided smart contract, we will analyze each function that involves security-sensitive operations, particularly those that transfer Ether or tokens, and evaluate their access control mechanisms.

1. **Function: `claim`**
   - **Operation**: Transfers tokens using `tokenContract.transfer`.
   - **Visibility**: Public
   - **Access Control**: Protected by the `onlyRC` modifier, which requires the caller to be in the `rc` mapping.
   - **Explanation**: This function allows any address in the `rc` mapping to transfer tokens to a specified `_buyer`. The access control is based on the `rc` mapping, which can be modified by the `addMeByRC` function, requiring the transaction origin to be the owner. This provides a level of access control, but the function itself is sensitive as it allows token transfers.

2. **Function: `withdrawTokens`**
   - **Operation**: Transfers tokens using `tokenContract.transfer`.
   - **Visibility**: Public
   - **Access Control**: Protected by the `onlyOwner` modifier.
   - **Explanation**: This function allows the owner to transfer tokens to a specified address. The access control is robust as it is restricted to the contract owner.

3. **Function: `forward`**
   - **Operation**: Transfers Ether to `advisor` and `wallet`.
   - **Visibility**: Internal
   - **Access Control**: Called internally by `buyFromRC`, which is protected by `onlyRC` and `isBuyable` modifiers.
   - **Explanation**: This function splits and transfers Ether to the `advisor` and `wallet` addresses. The access control is indirect, relying on the `buyFromRC` function's modifiers.

4. **Function: `withdraw`**
   - **Operation**: Transfers Ether using `to.transfer`.
   - **Visibility**: Public
   - **Access Control**: Protected by the `onlyOwner` modifier.
   - **Explanation**: This function allows the owner to withdraw Ether to a specified address. The access control is robust as it is restricted to the contract owner.

5. **Function: `buyFromRC`**
   - **Operation**: Transfers tokens using `tokenContract.transfer` and Ether using `_buyer.transfer`.
   - **Visibility**: Public
   - **Access Control**: Protected by `onlyRC` and `isBuyable` modifiers.
   - **Explanation**: This function allows addresses in the `rc` mapping to facilitate token purchases and handle refunds. The access control is based on the `rc` mapping, which is modifiable by the owner, providing a level of access control.

**Conclusion**: Based on the analysis, the following functions are identified as sinks due to their security-sensitive operations and the level of access control applied:

--Sink--:
{Function: claim, Sink: token transfer, Visibility: public, Explanation: Allows addresses in the `rc` mapping to transfer tokens, access controlled by `onlyRC`.}
{Function: withdrawTokens, Sink: token transfer, Visibility: public, Explanation: Allows the owner to transfer tokens, access controlled by `onlyOwner`.}
{Function: forward, Sink: Ether transfer, Visibility: internal, Explanation: Transfers Ether to `advisor` and `wallet`, access controlled indirectly by `buyFromRC`.}
{Function: withdraw, Sink: Ether transfer, Visibility: public, Explanation: Allows the owner to withdraw Ether, access controlled by `onlyOwner`.}
{Function: buyFromRC, Sink: token and Ether transfer, Visibility: public, Explanation: Allows addresses in the `rc` mapping to facilitate token purchases and refunds, access controlled by `onlyRC` and `isBuyable`.}
Report:
To determine whether untrusted inputs can reach any security-sensitive operations (sinks) in the `TokenSale` contract, we will examine each identified sink and trace any possible paths from untrusted sources to these sinks.

### Step 1: Identify Taint Sources
- **Untrusted Inputs:** 
  - `msg.sender`: The address initiating a function call, untrusted in any public/external function.
  - `tx.origin`: The original address initiating a transaction, also untrusted.

### Step 2: Taint Propagation Path Analysis

1. **Function: claim**
   - **Sink:** Token transfer
   - **Access Control:** The function uses the `onlyRC` modifier.
   - **Analysis:** 
     - `onlyRC` checks if `rc[msg.sender]` is `true`, which means only addresses in the `rc` mapping can call this function.
     - The mapping `rc` is modified in the function `addMeByRC`, which requires `tx.origin` to be `owner`. Therefore, unauthorized addresses cannot taint the execution path.
   - **Conclusion:** No taint path from untrusted sources to this sink.

2. **Function: withdrawTokens**
   - **Sink:** Token transfer
   - **Access Control:** The function is protected by the `onlyOwner` modifier.
   - **Analysis:** 
     - Only the owner can call this function. As `owner` is set upon contract deployment and can only be modified through ownership transfer mechanisms not exposed here, unauthorized addresses cannot taint this path.
   - **Conclusion:** No taint path from untrusted sources to this sink.

3. **Function: forward**
   - **Sink:** Ether transfer
   - **Access Control:** This function is `internal` and indirectly accessed through `buyFromRC`.
   - **Analysis:** 
     - `buyFromRC` is protected by the `onlyRC` modifier, which restricts access to registered addresses in the `rc` mapping, requiring them to be added via `addMeByRC` with `tx.origin == owner`.
     - The `isBuyable` modifier enforces time constraints and requires a positive `msg.value`, which does not control access but ensures conditions are right for buying.
   - **Conclusion:** No taint path from untrusted sources to this sink.

4. **Function: withdraw**
   - **Sink:** Ether transfer
   - **Access Control:** The function is protected by the `onlyOwner` modifier.
   - **Analysis:** 
     - Only the owner can call this function, maintaining secure access control.
   - **Conclusion:** No taint path from untrusted sources to this sink.

5. **Function: buyFromRC**
   - **Sink:** Token and Ether transfer
   - **Access Control:** The function uses both `onlyRC` and `isBuyable` modifiers.
   - **Analysis:** 
     - Similar to `claim`, the `onlyRC` modifier ensures only trusted and verified addresses can execute the function.
     - Time and value conditions enforced by `isBuyable` are not access controls, and they do not introduce vulnerabilities.
   - **Conclusion:** No taint path from untrusted sources to this sink.

### Step 3: Self-Evaluation
Based on the taint analysis, all sensitive functions have effective access control that prevents untrusted inputs from reaching critical sinks. No untrusted sources can influence sensitive operations due to adequate usage of access control mechanisms.

--Vulnerability--: 
no vulnerability
--Tx.origin Vulnerability--:
{Function: addMeByRC, Explanation: Uses tx.origin as condition.}

==============End======================
total time: 72.24546360969543
total token: 12994