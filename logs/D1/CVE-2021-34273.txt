Solidity Version: 0.4.24
Switched global version to 0.4.24
==============Start====================
rules:
{Function:owned, Visibility:public, Explanation:Writes to variable owner without any access control.}

=============Contract: Owned
Sink:
Step 2: **Identify Sink**:

1. **Function: `owned`**:
   - The `owned` function writes to the variable `owner` without any access control. Since this function is intended to act as a constructor but lacks the `constructor` keyword, it can be invoked by anyone. This is a critical issue because any address can set itself as the `owner` of the contract. This operation is a security-sensitive operation because it modifies the ownership of the contract without any restriction, hence it qualifies as a sink.

2. **Function: `transferOwnership`**:
   - The `transferOwnership` function is protected by the `onlyOwner` modifier, which requires the caller to be the current `owner`. This modifier serves as a basic access control mechanism to ensure that only the contract owner can execute this function. It does not qualify as a sink because it contains an appropriate access control check.

Step 3: **Self-Evaluate and Explain**:

- **Sink Identification for `owned` function**:
  - **Function**: `owned`
  - **Sink**: `owner` assignment
  - **Visibility**: `public`
  - **Explanation**: The `owned` function sets the `owner` to the `msg.sender` without any restriction or access control. This function can be called by anyone due to its `public` visibility, allowing them to take ownership of the contract, which poses a significant security risk.

--Sink--:
{Function: owned, Sink: owner assignment, Visibility: public, Explanation: The function sets the owner to msg.sender without access control, allowing anyone to become the contract owner.}
Report:
Let's perform a thorough taint analysis of the provided contract:

### Step 1: **Taint Source Identification**

- **Sink Identified**: The function `owned`, which sets the `owner` variable to `msg.sender`, is a sink because it has public visibility, allowing any external account to invoke it. Therefore, `msg.sender` here acts as an untrusted input.
  
### Step 2: **Taint Propagation Path Analysis**

1. **Function Analysis**:
    - **Function `owned()`**:
      - **Visibility**: Public
      - **Behavior**: Sets the contract's `owner` variable to the `msg.sender`.
      - **Taint Source**: The `msg.sender` can be any external address calling this function.

2. **Access Control**:
    - **Modifiers**:
      - The contract defines an `onlyOwner` modifier, which ensures that certain functions, such as `transferOwnership`, can only be executed by the current `owner`.
    - **Application of `onlyOwner`**:
      - The `transferOwnership` function uses the `onlyOwner` modifier to restrict access. It prevents unauthorized changes to the `owner` by ensuring only the current `owner` can call it.

3. **Path from Untrusted Source to Sink**:
    - The `owned()` function directly assigns `msg.sender` to the `owner` variable without any checks or restrictions. There is no modifier or require statement limiting access to this function.
    - There is a direct path from `msg.sender` to the `owner` assignment, indicating that any address can call `owned()` and set themselves as the `owner`.

### Step 3: **Self-Evaluation**

The analysis reveals that the function `owned()` can be called by any external account due to its public visibility, allowing any address to become the contract owner without any access control checks.

**Conclusion**:

--Vulnerability--:
{Function: owned, Taint Path: msg.sender -> owner assignment, Description: The function allows any address to become the contract owner, resulting in an access control vulnerability.}


rules:
{Function:distributeToken, Visibility:public, Explanation:Writes to variable balances without any access control.}
{Function:approve, Visibility:public, Explanation:Writes to variable allowed without any access control.}

=============Contract: StandardToken
Sink:
Step 1: **Reference**:
The static analysis highlights two functions as potentially problematic: `distributeToken` and `approve`. The reasoning is based on their public visibility and their ability to write to sensitive mappings without explicit access control.

Step 2: **Identify Sink**:

1. **Function `distributeToken`:**
   - **Operation**: The function iterates over an array of addresses, subtracting a value from the caller's balance (`balances[msg.sender]`) and adding it to each address's balance (`balances[addresses[i]]`). 
   - **Visibility**: The function is publicly accessible.
   - **Security Concern**: This operation directly modifies balances of multiple addresses without any access control checks, such as verifying ownership or authorization. This means that anyone can call this function and distribute tokens from their own balance indiscriminately, potentially leading to unintended loss of tokens or manipulation of balances.

2. **Function `approve`:**
   - **Operation**: Sets the allowance for a `_spender` to spend a specified amount of tokens on behalf of the caller (`msg.sender`).
   - **Visibility**: The function is publicly accessible.
   - **Security Concern**: While this function follows the typical ERC-20 pattern for approving allowances, the static analysis flagged it due to the lack of direct access control checks within the function itself. However, this is typical for ERC-20 standards, where allowance settings are inherently open but executed by the token holder themselves. Despite being flagged, this is not a sink because it conforms to the standard mechanism expected for token allowances, which are modified by the token owner.

Step 3: **Self-Evaluate and Explain**:

- **Function `distributeToken`:**
  - **Explanation**: The function writes directly to the `balances` mapping for multiple addresses without access control, allowing any caller to adjust balances based solely on the input parameters they provide. This lack of control can lead to unauthorized token distribution.

- **Function `approve`:**
  - **Explanation**: Although flagged in the analysis, this function follows standard ERC-20 design, where the token holder sets allowances for others to spend their tokens. As this operates under the presumption that the token holder themselves initiates the approval, it is not considered a sink in terms of unauthorized access control.

Conclusion:

--Sink--:
{Function: distributeToken, Sink: balances modification, Visibility: public, Explanation: Writes to `balances` without any access control, allowing unauthorized token distribution.}
--Sink--: 
no sinks for approve function as it aligns with ERC-20 standards.
Report:

==============End======================
total time: 14.212071418762207
total token: 5420